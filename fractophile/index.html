<!DOCTYPE html>

<html>

<head>
<title>Fractophile</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<style>
img { height:100px }

.hidden {display:none}
.sampleDiv {
        position: absolute;
        z-index: 1000;
}

</style>

</head>

<body onload="webGLStart();" style="overflow:hidden">

    <!-- set oncontextmenu="return false" to nullify right click menu -->

    <div id="canvas01_div" onmouseover="drawScene()" style="position:absolute; top:0px; left:0px; font-size:10px; z-index:-1">
        <canvas id="canvas01" style="border: none;" oncontextmenu="return true"></canvas>
    </div>

    <!-- see webGLStart() for creation of user_params -->
    <div id="user_params">
    </div>
  
    <span> 
        <button id="loadSample" onclick="showSamples()" >Load Sample</button>
        <a href="./fractophile_instructions.html" target="_blank"> <button id="instructions" >Instructions</button> </a>
    </span>

    <div class="hidden sampleDiv" id="loadSampleDiv" onclick="loadSample(event)">
        <img id="sample-00" src="./cosmic_jungle.jpg" /> 
        <img id="sample-01" src="./logz_rings.jpg"    /> 
        <img id="sample-02" src="./pastel_colors.jpg" />
        <img id="sample-03" src="./exp_laser.jpg" />
        <img id="sample-04" src="./sunrise.jpg" />
        <img id="sample-05" src="./alien_corpse.jpg" />
        <img id="sample-06" src="./bw01.jpg" />
        <img id="sample-07" src="./nice_spiral.jpg" />
        <img id="sample-08" src="./boxy01.jpg" />
        <img id="sample-09" src="./icy_sky.jpg" />
        <img id="sample-10" src="./inside_out.jpg" />
        <img id="sample-11" src="./pure_beauty.jpg" />
        <img id="sample-12" src="./stone_carving.jpg" />
        <img id="sample-13" src="./strange.jpg" />
        
    </div>

    <div id="save_file" style="position:absolute; top:40px; left:10px; z-index:0; font-size:12px; background-color:lightblue; width:212px" >

        <button style="font-size:12px; width:80px" onclick="downloadFile()" >Create File</button>
        <input type="text" id="download_file" value="fract01.txt" placeholder="filename.txt" style="font-size:12px; width:105px">
        <br>
        <output></output> 
        
        <!-- this is very cool - just adding the file input type adds a Choose File button which allows one
             to choose a file which is saved in the file_list object and passed to the callback function
             add multiple qualifier to choose multiple files -->
        <input type="file" id="files" name="files[]" style="font-size:12px"/>
        <output id="file_list"></output>
    </div>

    <div id="d2" style="position:absolute; top:90px; left:10px; z-index:0; font-size:12px; overflow:scroll; height:220px; background-color:lightblue">
        <form autocomplete="off">

            <!--adding a title="" attribute will show the title on hover but there is an annoying delay -->
            <input type="number" id="zoom_multiplier" value="1.0" style="font-size:10px; width:80px"/> Zoom Factor
            <br>

            <input type="text" id="current_wheel_param" value="Mix_Factor" style="font-size:10px; width:80px"/> Current Wheel Param 
            <br>

            <input type="text" id="mouse_wheel" style="font-size:10px; width:80px"/> Mouse Wheel 
            <br> 

            <input type="text" id="wheel_param_value" value="1.0" style="font-size:10px; width:80px" /> Wheel Param Value 
            <br>

            <input type="number" id="wheel_param_delta" value=".002" style="font-size:10px; width:80px"/> Wheel Param Delta 
            <br>

            <input type="number" id="zoomOutput" value="1.0" disabled style="font-size:10px; width:80px"/> Total Zoom
            <br>

            </label> <input type="text" id="zoomCenterXInput" value="0.0" style="font-size:10px; width:80px"/> Real Coord
            <br>
            </label> <input type="text" id="zoomCenterYInput" value="0.0" style="font-size:10px; width:80px"/> Imag Coord
            <br>

            <input type="text" id="centerX" style="font-size:10px; width:80px" />  center X<br>
            <input type="text" id="centerY" style="font-size:10px; width:80px" />  center Y<br>
            <input type="text" id="width" style="font-size:10px; width:80px"/>  width<br>
            <input type="text" id="height" style="font-size:10px; width:80px"/>  height <br>

            <input type="number" id="canvas_mult" value="1.0" style="font-size:10px; width:80px" onchange="resizeCanvas()"/> Canvas Mult <br>  
            <input type="number" id="tex_size_mult" value="0" style="font-size:10px; width:80px" onchange="adjust_texture_size()" /> Tex Size Mult<br> 
            <input type="number" id="tex_map_num" value="0" style="font-size:10px; width:80px" onchange="load_new_texture()"/> Texture Map #<br>             

            <input type="button" onclick="run_recording()" style="font-size:10px"> Run
            <input type="button" onclick="stop_running()" style="font-size:10px"> Stop
            <br>
 
            <input type="number" id="last_frame" value="0" style="font-size:10px; width:80px"> Last Frame <br>
            <input type="number" id="scene_number" value="0" style="font-size:10px; width:80px"> Current Frame #<br>
            <input type="number" id="start_frame" value="0" style="font-size:10px; width:80px"> Starting Frame #<br>
            <input type="number" id="fps" value="10" style="font-size:10px; width:80px"> FPS <br>

            
            <input type="button" onclick="make_delta_smaller()" style="font-size:10px" /> Reduce Change in Wheel Param
            <br>
            <input type="checkbox" id="julia_param_checkbox" onclick="julia_param_from_mouse()" style="font-size:10px" /> Change Params using Mouse
            <br>
            <input type="checkbox" onclick="toggle_recenter_julia_params()" style="font-size:10px" /> Toggle Recenter Julia Params
            <br>
            <input type="checkbox" id="snapshot_checkbox" onclick="toggle_snapshot()" style="font-size:10px" /> Snapshot Mode

        </form>

    </div>

</body>

<script id="shader-fs" type="x-shader/x-fragment">
     
    //how the hell do we pass data back from the frag shader?  like number of iterations done per pixel?
    //answer: do everything per pixel in the vertex shader then pass a data struct to the frag shader

    precision highp float;
    varying   vec2        vPosition;
    uniform   float       params[67];
    uniform   float       mouse_coords[12];

    uniform   sampler2D   texture1;   //we might get colors from a texture map

    const float pi = 3.14159265;
    const float two_pi = 2.0 * pi;
    const float pi_over_2 = 1.570796325;
    const float too_small = 1e-7;        
    const float one_third = 1.0/3.0;
    float x,y,xy,x2,y2,xy2,x4,y4,x6,y6,x8,y8;
    float modz,modz2,modz5;
    float ex,cosy,siny,yz,emx,ex2,zx,zy,zx5,zy5;
    vec3  roots_re;
    vec3  roots_im;

    //double doubleTest = 0.;

    float z;  //for adding a dimension

    //http://www.rapidtables.com/convert/color/hsl-to-rgb.htm
    vec3 hsltorgb(float h, float s, float l) {

        //this is not changing continuously and is skipping colors
        //but the logic for the mapping is clearer
        float r,b,g;
        float c = (1.0-abs(2.0*l-1.0))*s;  //"chroma"

        int hh  = int(h/60.0);
        float hh2 = 1.0;
        if ( hh/2 == 0 ) { hh2 = 0.0; }      
        float x = c*(1.0-abs(hh2-1.0));    //same "hue" and "chroma"
        float m = l-c/2.0;

        if      (h<=60.0)  {r=c;   g=x;   b=0.0;}
        else if (h<=120.0) {r=x;   g=c;   b=0.0;}
        else if (h<=180.0) {r=0.0; g=c;   b=x;  }
        else if (h<=240.0) {r=0.0; g=x;   b=c;  }
        else if (h<=300.0) {r=x;   g=0.0; b=c;  }
        else if (h<=360.0) {r=c;   g=0.0; b=x;  }
        r += m;
        g += m;
        b += m;

        return vec3(r,g,b);
    }

    float hue2rgb(float p, float q, float t)
    {
        //do not yet understand why this is equiv to hsltorgb
        if (t<0.0) t+=1.0;
        if (t>1.0) t-=1.0;
        if (t<1.0/6.0) return p + (q-p)*6.0*t;
        if (t<1.0/2.0) return q;
        if (t<2.0/3.0) return p + (q-p) * (2.0/3.0-t) * 6.0;
        return p;
    }

    vec3  hsl2rgb(float hue, float s, float l) 
    {                
        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
        float p = 2.0 * l - q;  
       
        return vec3(         
            hue2rgb(p,q,hue+one_third),
            hue2rgb(p,q,hue),
            hue2rgb(p,q,hue-one_third)
        );
    }

    void init_z2() {
        x2 = x*x;
        y2 = y*y;
        xy = x*y;
        zx = x2 - y2;
        zy = 2.0*xy;
    }
 
    void init_inverse_z2() {
        init_z2();
        x4  = x2*x2;
        y4  = y2*y2;
        xy2 = xy*xy; 
        modz2 = max(x4 + y4 + 2.0 * xy2, too_small);
    }

    void init_trig() {
        ex   = exp(x);
        cosy = cos(y);
        siny = sin(y);
    }
 
    void init_trig2() {
        modz = max(x2+y2,too_small);
        init_trig();
        yz = y/modz;
        ex2 = exp(x/modz);
    }

    void init_inverse_z5() {

        x2  = x*x;
        y2  = y*y;
        x4  = x2*x2;
        y4  = y2*y2;                
        x6  = x4*x2;     
        y6  = y4*y2;     
        x8  = x4*x4;     
        y8  = y4*y4;
     
        zx5 = x4*x - 10.0*x2*x*y2 + 5.0*x*y4;     
        zy5 = y4*y - 10.0*x2*y2*y + 5.0*x4*y;

        modz5 = max( x8*x2 - 20.0*x8*y2 + 100.0*x6*y4 - 100.0*x4*y6 + 25.0*x2*y8
                   + y8*y2 - 20.0*x2*y8 + 100.0*x4*y6 - 100.0*x6*y4 + 25.0*x8*y2, too_small);
    }

    float atanyx(float y, float x) {

        float sign_y = 1.0;
        if (y < 0.0) sign_y = -1.0;
        
        if (abs(x) < too_small) return sign_y * pi_over_2;

        float atanyx = atan(y/x);

        //we need to add multiple of pi depending on the quadrant
        if (x>0.0 && y>=0.0) {
            return atanyx;
        }
        else if (x<0.0) {
            return pi + atanyx;
        }
        else {
            return two_pi + atanyx;
        }
    }

    // do not let VisualStudio try to autoformat this section in javascript mode
    // this is a program that gets compiled and sent to the GPU
    // the web browser is able to bind javascript variables
    // into the program , for example vPosition

    // START OF main() of GPU PROGRAM
    void main() 
    {    
         
            float cx = vPosition.x;
            float cy = vPosition.y;           

            vec3 save_rgb;
            float alpha;

            float color_index;
            int escape_value = 0;

            x = 0.0;
            y = 0.0;
	      z = params[57];

            float new_x = 0.0;
            float new_y = 0.0;
            float new_z = 0.0; 

            float prev_x  = 0.0;
            float prev_y  = 0.0;
            float prev2_x = 0.0;
            float prev2_y = 0.0;
	
            float angle = 0.0; 	
	          
            int imax_iter = int(params[0]);
            int function_choice = int(params[15]);

            float w1 = params[1];
            float w2 = 1.0 - params[1];

            float nw1 = params[33];
            float nw2 = 1.0 - params[33];

            float cx1,cy1;
                    
            float costheta;
            float sintheta;
            float cosphi;        
            float sinphi;
            float cospsi;
            float sinpsi; 

            float jcostheta;
            float jsintheta;
            float jcosphi;        
            float jsinphi;
            float jcospsi;
            float jsinpsi;

            if (params[34]==3.0) {        
                jcostheta=cos(params[54]);
                jsintheta=sin(params[54]); 
                jcosphi=cos(params[55]);
                jsinphi=sin(params[55]);
                jcospsi=cos(params[56]);
                jsinpsi=sin(params[56]);
            }        

            if (params[28]==2.0) { //|| params[28]==3.0) {        
                costheta=cos(params[51]);
                sintheta=sin(params[51]); 
                cosphi=cos(params[52]);
                sinphi=sin(params[52]);
                cospsi=cos(params[53]);
                sinpsi=sin(params[53]);
            }

            if (params[27] > 0.0) {
                //this tiles the whole plane with square copies
                //cx = params[27]*sin(cx)*cos(cy);
                //cy = params[27]*sin(cx)*sin(cy);
                cx = cos(params[27]*cx);
                cy = sin(params[27]*cy);
            }

            if (params[26] > 0.0 || params[35] > 0.0) {
                //invert plane in unit circle
                //mouse_coords[] is not saved to JSON so recording of inverted mouse moves does not occur
                float cx2 = cx;
                float cy2 = cy;
                if (params[35] > 0.0) {
                    cx2 = cx - mouse_coords[3];
                    cy2 = cy - mouse_coords[4];
                }
                float modz = max(cx2*cx2 + cy2*cy2, too_small);
                cx /= modz*(params[26]+params[35]);
                cy /= modz*(params[26]+params[35]);
            }

            if (params[18] > 0.0 )  {  //|| function_choice==19) {
                //Julia set instead of Mandelbrot
                //newton always gets Julia because cx,cy must stay constant since it
                //determines the roots

                x = cx;
                y = cy;

                //control of this parameter by mouse or keys is all taken care of in javascript
                //mouse_coords[] updates Param_Radius and Param_Angle when julia_mouse=1
                {
                    //cx1 and cy1 replace cx and cy
                    cx = params[16]*cos(params[17]);
                    cy = params[16]*sin(params[17]);

                    if (params[64] > 0.0) {
                        cx = mouse_coords[9];
                        cy = mouse_coords[10];
                    }
                }
            }

            float max_x = 0.0;
            float max_y = 0.0;
            float newton_iter = 0.0;
            int newton_root_found = 0;
 
            if (function_choice==19) {

                //cube roots of unity - should send this in via javascript
                float theta = 2.0 * pi / 3.0;

                for (int i=0; i<3; ++i) {
                    roots_re[i] = cos(float(i+1)*theta);
                    roots_im[i] = sin(float(i+1)*theta);
                }
            }
           
            float q1=0.0,q2=0.0,q3=0.0,q4=0.0;  //sums of iterates laying in 4 quadrants
            int   num_iter=0;
  
            float xder=1.0,yder=0.0,tmp_xder=0.0;

            float total_angle_sum = 0.0;

            prev_x = x;
            prev_y = y;

            //shader programs are NOT exactly C programs		
            //for loop conditionals must have all constants for example
            //they are expected to be parallelizable across each point on the screen
            //need to use break in order to have a variable for loop
            for ( int i=0; i<5000; ++i )
            {                     
                num_iter = i;

                //params[] correspond to the ids in global array var params[]
                //I am going to reference the indices directly - heaven's forrbid

                //GLSL does not have function pointers so we need to use if/else
                //looks like if statements do not seriously detract from perf so we do not
                //have to go crazy recompiling shader everytime we want a different function
                {

                    if (function_choice==0) {                
                        //mandelbrot + exponential
                        init_z2();
                        init_trig();
                        new_x =  w1*zx + w2*(ex*cosy) + cx;
                        new_y =  w1*zy + w2*(ex*siny) + cy;  

                        //dz here
                        tmp_xder = 2.0 * (new_x*xder - new_y*yder);  // + 1.0;
                        yder     = 2.0 * (new_y*xder + new_x*yder);
                    }

                    else if (function_choice==1) {
                        //mandelbrot + inverse mandelbrot
                        init_inverse_z2();
                        new_x =  w1*zx  + w2*(zx/modz2) + cx;
                        new_y =  w1*zy  + w2*(-zy/modz2) + cy;  

                        //dz here
                        tmp_xder = 2.0 * (new_x*xder - new_y*yder);  // + 1.0;
                        yder     = 2.0 * (new_y*xder + new_x*yder);               
                    }

                    else if (function_choice==2) {
                        //exponential + inverse mandelbrot
                        init_inverse_z2();
                        init_trig();
                        new_x = w1*(ex*cosy) + w2*(zx/modz2) + cx;
                        new_y = w1*(ex*siny) + w2*(-zy/modz2) + cy;
                        //new_x = (zx/modz2) + cx;
                        //new_y = (-zy/modz2) + cy;
                    }
 
                    else if (function_choice==3) {
                        //exp of 1/z^2 + 1/z^2 
                        init_inverse_z2();
                        init_trig2();
                        new_x = w1*(ex2*cos(-yz))  + w2*(zx/modz2) + cx;
                        new_y = w1*(ex2*sin(-yz))  + w2*(-zy/modz2) + cy;
                    }

                    else if (function_choice==4) {
                        //exp of 1/z + exp
                        x2 = x*x;
                        y2 = y*y;
                        init_trig2();
                        new_x = w1*(ex2*cos(-yz))  + w2*(ex*cosy) + cx;
                        new_y = w1*(ex2*sin(-yz))  + w2*(ex*siny) + cy;
                    }

                    else if (function_choice==5) {
                        //z^5+c
                        init_inverse_z5();
                        new_x =  w1*zx5/modz5 + w2*(zx5) + cx;
                        new_y =  w1*zy5/modz5 + w2*(-zy5) - cy;  
                    }

                    
                    else if (function_choice==6) {
                        //for FLT               
                        //float theta = 0.0;
                        //if (abs(x) > too_small) theta = atan(y/x);

                        float theta2 = float(i) * params[1];

                        float xx = cx*cos(cy*theta2*params[16]);
                        float yy = cy*sin(cx*theta2*params[16]+params[17]);

                        float br = xx;
                        float cr = xx;
                        float dr = xx;

                        float bi = yy;
                        float ci = yy;
                        float di = yy;
                        //end FLT

                        init_z2();
                        //Fractional Linear az+b/cz+d Transformation
                        new_x =   (cx*cr-cy*ci)*(x2-y2) - (cx*ci+cy*cr)*2.0*xy 
                                 +(cx*dr-cy*di)*x       - (cx*di+cy*dr)*y
                                 +(br*cr-bi*ci)*x       - (br*ci+bi*cr)*y
                                 +(br*dr-bi*di);
                        new_y =   (cx*ci+cy*cr)*(x2-y2) + (cx*cr-cy*ci)*2.0*xy
                                 +(cx*di+cy*dr)*x       + (cx*dr-cy*di)*y
                                 +(br*ci+bi*cr)*x       + (br*cr-bi*ci)*y
                                 +(br*di+bi*dr);            
                    }
                    
 
                    else if (function_choice==7) {
                        //creates nice angular patterns in the Fatou region
                        init_inverse_z2();

                        new_x =  w1*abs(zx) + w2*abs(zx/modz2) + cx;
                        new_y =  w1*abs(zy) + w2*abs(zy/modz2) + cy;

                    }
             
                    else if (function_choice==8) {
                        emx = exp(-x);
                        init_trig();
                        // for complex sine and cosine
                        float s1 = ex + emx;
                        float s2 = ex - emx;
                        new_x = w1*( s1*cosy ) + w2*( s2*cosy ) + cx;
                        new_y = w1*( s1*siny ) + w2*( s2*siny ) + cy;   
                    }

                    else if (function_choice==9) {
                        init_inverse_z2();
                        init_trig();
                        //new_x = w1*(ex*(cx*cosy-cy*siny)) + w2*( zx/modz2 + cx);
                        //y     = w1*(ex*(cx*siny+cy*cosy)) + w2*(-zy/modz2 + cy);

                        new_x = w1*(ex*(cx*cosy-cy*siny)) + w2*( ex*(cx*siny-cy*cosy));
                        new_y = w1*(ex*(cx*siny+cy*cosy)) + w2*( ex*(cx*cosy+cy*siny));

                    }

                    else if (function_choice==10) {
                        init_z2();
                        init_trig();
                        new_x = w1*(ex*(cx*cosy-cy*siny)) + w2*(zx+cx); 
                        new_y = w1*(ex*(cx*siny+cy*cosy)) + w2*(zy+cy);
                    }

                    else if (function_choice==11) {
                        init_inverse_z5();
                        init_trig();
                        new_x =  w1*zx5/modz5 + w2*(ex*cosy) + cx;
                        new_y =  w1*zy5/modz5 + w2*(ex*siny) + cy;
                    }

                    else if (function_choice==12) {
                        init_z2();
                        float ex2 = exp(-x2+y2);
                        float cosxy = cos(2.0*xy);
                        float sinxy = sin(2.0*xy);
                        new_x = w1*( ex2*cosxy ) + cx;
                        new_y = w1*( ex2*sinxy ) + cy;
                    }

                    else if (function_choice==13) {
                        init_z2();
                        init_trig();
                        modz = max(x2+y2,too_small);
                        new_x =  w1*( x*ex*cosy + y*ex*siny)/modz + w2*(zx) + cx;
                        new_y =  w1*(-y*ex*cosy + x*ex*siny)/modz + w2*(zy) + cy;
                    }
                    else if (function_choice==14 || function_choice==15) {

                        //exp(z^2+c) and exp(1/z^2+c)
                        init_inverse_z2();
                        float exp_cx = exp(cx);
                        float cos_cy = cos(cy);
                        float sin_cy = sin(cy);
                        float cos_2xy = cos(2.0*xy);
                        float sin_2xy = sin(2.0*xy);
                        float exp_c = w1 * exp(zx)*exp_cx;
                        float exp_c2 = w2 * exp(zx/modz2)*exp_cx;
                        float xyi = 2.0*xy / modz2;
                        float cos_2xyi = cos(xyi);
                        float sin_2xyi = sin(xyi);

                        //new_x = exp_c * ( cos_cy*cos_2xy - sin_cy*sin_2xy ) + exp_c2 * (cos_cy*cos_2xyi - sin_cy*sin_2xyi )  + .2*(zx+cx);
                        //new_y = exp_c * ( cos_cy*sin_2xy + sin_cy*cos_2xy ) + exp_c2 * (cos_cy*sin_2xyi - sin_cy*cos_2xyi )  + .2*(zy+cy);

                        if (function_choice==14) {
                            //everything seems to be better with a little mandelbrot mixed in
                            new_x = w1*( zx + cx) + exp_c2 * (cos_cy*cos_2xyi - sin_cy*sin_2xyi );
                            new_y = w1*( zy + cy) + exp_c2 * (cos_cy*sin_2xyi - sin_cy*cos_2xyi );
                        }

                        else if (function_choice==15) {
                            new_x = w1*( zx/modz2 + cx) + exp_c2 * (cos_cy*cos_2xyi - sin_cy*sin_2xyi );
                            new_y = w1*(-zy/modz2 + cy) + exp_c2 * (cos_cy*sin_2xyi - sin_cy*cos_2xyi );
                        }
                    }

                    else if (function_choice==16) {

                        init_inverse_z2();

                        //init_trig();
                        //new_x = max( w1 * zx+cx, w2*zx/modz2+cx);
                        //new_y = max( w1 * zy+cy, w2*-zy/modz2+cy);

                        new_x = w1*zx*atan(zx) + w2* zx/modz2*atanyx( zx, modz2) + cx;
                        new_y = w1*zy*atan(zy) + w2*-zy/modz2*atanyx(-zy, modz2) + cy;
 
                    }
 
                    else if (function_choice==17) {
                        init_z2();
   
                        float mult1 = 1.0;
                        float r = max(sqrt(x*x + y*y),too_small);
                        if (params[57] < 0.0) {
                            r = 1.0/r;
                            mult1 = -1.0;
                        }

                        //this is much nicer with the "wrong" atan which does not look at quadrant
                        float theta = abs(x)>too_small ? atan(y/x) : 0.0;
                        float ln_r = log(r);

                        // clog(z) is not nearly as nice as just log(z) + c
                        //new_x = cx * ln_r  - cy * theta;
                        //new_y = cx * theta + cy * ln_r;

                        //wow!  best stuff is ~ 1.1 * logz - .1 z^2
                        new_x = w1 * ln_r  + w2 * zx + cx;
                        new_y = mult1 * w1 * theta + w2 * zy + cy; 
                    }

                    /*
                    else if (function_choice==18) {
                        init_z2();
                        //a = cos(cos(x)) if Tile is > 0.0
                        float a = cos(x);
                        float b = sin(y);
                        float r = max(sqrt(a*a + b*b), too_small);
                        float theta = atanyx(b,a);
                        float ln_r = log(r);

                        new_x = w1 * ln_r  + w2 * zx + cx;
                        new_y = w1 * theta + w2 * zy + cy;

                    }
                    */

                    else if (function_choice==19) {

                        //Newton root finding fractal here
                        init_inverse_z2();

                        //init_trig();
  
                        //modz2 *= 3.0; //pushed this into the function definition
                        //nice results too without the modz2, although this had a sign error
                        //new_x =  ( 2.0*(x4*x + x*y4 + 2.0*x*xy2) + cx*zx + cy*zy) / modz2;
                        //new_y =  (-2.0*(y4*y + x4*y + 2.0*y*xy2) + cy*zx - cx*zy) / modz2;
       
                        //mixed with exp - looks good
                        //new_x   =  w1*( 2.0*(x4*x + 2.0*x*xy2 + x*y4) + cx*zx + cy*zy) / modz2 / 3. +
                        //           w2*(ex*cosy + cx);
                        // new_y   =  w1*( 2.0*(y4*y + 2.0*y*xy2 + x4*y) + cy*zx - cx*zy) / modz2 / 3. +
                        //            w2*(ex*siny + cy);

                        new_x   =  w1*( 2.0*(x4*x + 2.0*x*xy2 + x*y4) + cx*zx + cy*zy) / modz2 / 3. +
                                   w2*(zx + cx);
                        new_y   =  w1*( 2.0*(y4*y + 2.0*y*xy2 + x4*y) + cy*zx - cx*zy) / modz2 / 3. +
                                   w2*(zy + cy);

                        vec3 distance_from_root,imag_diff;
                        for (int i=0; i<3; ++i) {
                            distance_from_root[i]  = new_x - roots_re[i];
                            imag_diff[i]           = new_y - roots_im[i];

                            //abs works as well as sqrt and costs less
                            //distance_from_root[i]  = abs(distance_from_root[i]);
                            //imag_diff[i]           = abs(imag_diff[i]);

                            distance_from_root[i]  *= (distance_from_root[i]);
                            imag_diff[i]           *= (imag_diff[i]);
 
                            //no point in taking sqrt
                            distance_from_root[i] += imag_diff[i];  //what was i thinking??

                            if (distance_from_root[i] < params[32]) {
                                newton_root_found = i + 1; 
                                break;
                            }
                        }
                    }
  
                    //20 if statements with heavy computations enclosed seems to be as much as the compiler can bear
                    //anymore and it gets memory exhausted error

                    /*
                    else if (function_choice==20) {

                        //z^2*log(z) + c
                        init_z2();
                        float theta = atanyx(y,x);
            
                        //this was a mistake since I forgot to take sqrt but it
                        //is still interesting
                        //float r = x2 + y2;
                        //float log_r = r > too_small ? log(r) : 0.0;

                        float r = max(sqrt(x*x + y*y),too_small);
                        float log_r = log(r);

                        new_x = w1 * (zx * log_r - zy * theta) + w2 * zx + cx;
                        new_y = w1 * (zx * theta + zy * log_r) + w2 * zy + cy;
                    }
                    */

                    /*
                    else if (function_choice==21) {
 
                        //atan(z) poorly approximated by z - z^3/3 + z^5/5
                        //not sure if i like it or not
                        init_inverse_z2();

                        new_x = w1*(15.0*x - 5.0*( x2*x - 3.0*x*y2) + 3.0*(x4*x - 10.0*x2*x*y2 + 5.0*x*y4))/15.0 +  w2* zx/modz2 + cx;
                        new_y = w1*(15.0*y - 5.0*(-y2*y + 3.0*x2*y) + 3.0*(y4*y - 10.0*x2*y*y2 + 5.0*x4*y))/15.0 +  w2*-zy/modz2 + cy;
                    }
                    */                    

                    /*
                    else if (function_choice==22) {
                        //logz/z
                        init_z2();
                        float theta = atanyx(y,x);
                        float r2 = x*x + y*y;          
                        float r = max(sqrt(r2),too_small);
                        float log_r = log(r);

                        r2 = max(r2,too_small);

                        new_x = w1 * ( x * log_r + y * theta) / r2 + w2 * zx + cx;
                        new_y = w1 * ( x * theta - y * log_r) / r2 + w2 * zy + cy;
                    }
                    */

                    /*
                    else if (function_choice==23) {
                        float x2 = x*x;
                        float y2 = y*y;
                        float x3 = x2*x;
                        float y3 = y2*y;
                        float x4 = x2*x2;
                        float y4 = y2*y2;
                        float xy = x*y;
                        
                        float ad_bc = 6.0*xy*(x2-y2+2.0*xy);                         

                        new_x = ( 2.0*x4*y-2.0*x3*y2-2.0*x2*y3+2.0*xy-x2-3.0*y2) + cx*ad_bc;
                        new_y = (-2.0*x*y4-2.0*x2*y3+2.0*x3*y2+2.0*xy-y2+3.0*x2) + cy*ad_bc;

                    }
                    */
 
                    /*
                    else if (function_choice==24) {
                        float sign_x = 1.0;
                        if (x < 0.0) sign_x = -1.0;
                        init_z2();

                        float a = cx;
                        float b = cy;
                        //float c = sin(x*y);
                        //float c = max(sin(x),sin(y));
                        //float c = x*y*sin(log(abs(cx+cy)));
                        float c = 0.0;
                        //pseudo Hopalong attractor
                        //we are really supposed to show all of the points in the orbit to get the full effect
                        new_x = w1*(y - sign_x*sqrt(abs(b*x-c))) + w2*(abs(zx) + cx);
                        new_y = w1*(a - x)                       + w2*(abs(zy) + cy);
                        
                    }
                    */
               
                    else if (function_choice==25) {
 
                        float x2 = x*x;
                        float y2 = y*y;
                        
                        float z3_re = x2*x - 3.0*x*y2;
                        float z3_im = -y2*y + 3.0*x2*y;
                        float z3_modsq = max(z3_re*z3_re + z3_im*z3_im, too_small);

                        //z^3 + 1/z^3 + c, actually has six fold symmetry due to the abs
                        new_x = w1*( abs(z3_re) ) + w2*(abs(z3_re/z3_modsq)) + cx; 
                        new_y = w1*( abs(z3_im) ) + w2*(abs(z3_im/z3_modsq)) + cy;                       
                    }

                    /*
                    else if (function_choice==26) {
                        
                    
                        float x2 = x*x;
                        float y2 = y*y;
                       
                        float a = 1.0; //cos(params[50]+pi/2.0);
                        float b = 1.0; //cos(params[50]+pi/2.0);
                        float c = 1.0; //cos(params[50]);
                        
                        float real_part = a + b*x + .5*x2 - .5*y2;
                        float imag_part = b*y + c*x*y;

                        float modsq = max( real_part*real_part + imag_part*imag_part, too_small );

                        //a+b*z+.5*c*z^2
                        new_x = w1*(real_part) + w2*(  real_part/modsq) + cx;
                        new_y = w1*(imag_part) + w2*( -imag_part/modsq) + cy; 
                    }
                    */
                    
                    else if (function_choice==27) {
 
                        //exponential version of #7
                        //creates nice angular patterns in the Fatou region
                        init_inverse_z2();
                        init_trig();

                        new_x =  w1*abs(ex*cosy) + w2*abs(zx/modz2) + cx;
                        new_y =  w1*abs(ex*siny) + w2*abs(zy/modz2) + cy;

                    }
                    
                    /*
                    else if (function_choice==28) {

                        float x2 = x*x;
                        float y2 = y*y;
                        
                        float x4 = x2*x2;
                        float y4 = y2*y2;
          
                        float x8 = x4*x4;
                        float y8 = y4*y4;

                        float x6 = x4*x2;
                        float y6 = y4*y2;

                        float z6_re = x6 - y6 - 15.0*x4*y2 + 15.0*x2*y4;
                        float z6_im = 6.0*x4*x*y + 6.0*x*y4*y - 20.0*x2*x*y2*y;

                        float z6_modsq = max(z6_re*z6_re + z6_im*z6_im, too_small);
 
                        float z3_re = x2*x - 3.0*x*y2;
                        float z3_im = -y2*y + 3.0*x2*y;

                        float z3_modsq = max(z3_re*z3_re + z3_im*z3_im, too_small);

                        //z^6 + 1/z^6 + c
                        //new_x = w1*( (z6_re) ) + w2*(z3_re/z3_modsq)  + cx;
                        //new_y = w1*( (z6_im) ) + w2*(-z3_im/z3_modsq) + cy;

                        new_x = w1*( (z6_re) ) + w2*(  z6_re / z6_modsq) + cx;
                        new_y = w1*( (z6_im) ) + w2*( -z6_im / z6_modsq) + cy;  

                    }
                    */
 
                   
                    else if (function_choice==29) {

                        float x2 = x*x;
                        float y2 = y*y;
        
                        float z3_re = x2*x - 3.0*x*y2;
                        float z3_im = -y2*y + 3.0*x2*y;

                        float z3_modsq = max(z3_re*z3_re + z3_im*z3_im, too_small);

                        new_x =   w1*abs(z3_re/z3_modsq) + w2*abs(z3_re) + cx;
                        new_y =   w1*abs(z3_im/z3_modsq) + w2*abs(z3_im) + cy;
                       
                    }
                             
                    /*
                    else if (function_choice==30) {

                        float x2=x*x, y2=y*y, z2=z*z;
                        
                        new_x =  exp(z2+y2)*cos(x2) + cx;
                        new_y =  exp(z2+y2)*sin(x2) + cy; 
                        new_z =  exp(z2+y2)*sin(z2) ;
                    }
                    */                   
                }

                prev2_x = prev_x;
                prev2_y = prev_y;

                prev_x = x;
                prev_y = y;

                //set old vars equal to new vars for next iteration
                x = new_x;	
                y = new_y;
		    z = new_z;
             
                //dz
                xder = tmp_xder;

                //useless
                //total_angle_sum += atanyx(new_y, new_x);

                //using the difference of the squares as a distance measure here yields interesting results sometimes	
                float distance = params[12]*x*x + params[13]*y*y;

                float abs_x = abs(x);
                float abs_y = abs(y);
                if (abs_x>max_x) max_x = abs_x;
                if (abs_y>max_y) max_y = abs_y;

                if (new_x >= 0.0) {
                    if (new_y >= 0.0) {
                        q1 ++;
                    }
                    else {
                        q2 ++;
                    }
                }
                else {
                    if (new_y >= 0.0) {
                        q3 ++;
                    }
                    else {
                        q4 ++;
                    }
                }

                if (  distance > params[2] ) {
                    escape_value = i;
                    break;
                }

                else if (newton_root_found > 0) {
                    
                    escape_value = 1 + newton_root_found;
                    newton_iter = float(i);
                    break;
                }	

                // stupid way of making the for loop variable   
                if (i > imax_iter ) break;
            }

            // fix numbers that are too large which are causing over runs and big black squares
            // there may be some other places but this is it for now
            float inf = 1e6;
            new_y = clamp(new_y, -inf, inf);
            new_x = clamp(new_x, -inf, inf);

            max_x = clamp(max_x, -inf, inf);
            max_y = clamp(max_y, -inf, inf);

            // the angle of the last point in the orbit when we bailed out		
            angle = atanyx(new_y,new_x);
                
            float lx1 = clamp(log(abs(new_x)), -inf, inf);
            float ly1 = clamp(log(abs(new_y)), -inf, inf);
            
            float final_r = clamp(new_x*new_x + new_y*new_y, -inf, inf);


            //float prev_r  = prev_x*prev_x + prev_y*prev_y;

            if (newton_root_found>0) {
                //newton
                lx1 = nw1 * (cx*cx + cy*cy) + nw2 * lx1;
                ly1 = nw1 * newton_iter     + nw2 * ly1;   
            }

            float x1b=0.0,y1b=0.0,angle2=0.0,pc=0.0,potential=0.0;
            float num_iterations = float(num_iter);
            float dem = 0.0;
            float ev = float(escape_value);
            const float log_2 = log(2.0);

            potential   = log( final_r ) / 2.0 ;

            if (params[66]==1.0) {
                if (escape_value == 0) {
                    //gl_FragColor = vec4( 0.0, 0.0, 0.0, 0.0 );
                    //gl_FragColor = vec4( new_x, new_y, 0.0, 0.0);
                    //gl_FragColor = vec4( vPosition.x, vPosition.y, 1, 1); //potential); 
                    gl_FragColor = vec4( vPosition.x, vPosition.y, potential, potential); 
                }
                else {
                    float pc =  ev - params[42] * log( potential / log_2 / params[43] ) / log_2;
                    gl_FragColor = vec4(0.,0.,0.,1.); //vec4( vPosition.x, vPosition.y, ev, pc );
                }
                return;
            }

            if ( escape_value != 0) {

                if (params[60] == 1.0) {
                    x1b    = lx1*params[7];
                    y1b    = ly1*params[8];
                    angle2 = angle*params[9];
                } 
                else if (params[60] == 2.0) {

                    //potential as described in Beauty of Fractal Images
                    float potential_x = log( new_x*new_x ) / 2.0; // pow(2.0,ev);
                    float potential_y = log( new_y*new_y ) / 2.0; // pow(2.0,ev);

                    //potential_x = clamp(potential_x,-inf,inf);
                    //potential_y = clamp(potential_y,-inf,inf);

                    x1b    = sin( clamp((lx1 - angle*params[42] * log(potential_x/log_2/params[43])) * params[7],-inf,inf) ) ;
                    y1b    = sin( clamp((ly1 - angle*params[42] * log(potential_y/log_2/params[43])) * params[8],-inf,inf) ) ;
                    angle2 = sin( angle*params[9]) ;

                    x1b *= x1b;
                    y1b *= y1b;
                    angle2 *= angle2;
                }
                else if (params[60] == 3.0) {
                    x1b    = q1/num_iterations * params[7]; //sin(q1/num_iterations * params[7]);
                    y1b    = q2/num_iterations * params[8]; //sin(q2/num_iterations * params[8]);
                    angle2 = q3/num_iterations * params[9]; //sin(q3/num_iterations * params[9]);
                }
                else if (params[60] == 4.0) {

                    //permutate the counts by quadrant
                    if (params[34]==0.0) {
                    }
                    else if (params[34]==1.0) { 
                        q1=q2; q2=q3; q3=q4;
                    }
                    else if (params[34]==2.0) {
                        q1=q3; q2=q4; q3=q1;
                    }
                    else if (params[34]==3.0) {
                        q2=q1; q3=q2;
                        q1=q4;
                    }
                    else if (params[34]==4.0) {
                        q1=q3; q3=q2; q2=q1;
                    }
                    else if (params[34]==5.0) {
                        q1 = q1 + q2;
                        q2 = q3 + q4;
                        q3 = 0.0;
                        q4 = 1.0;
                    }
                    gl_FragColor = vec4( cos(q1/num_iterations * params[7]),
                                         cos(q2/num_iterations * params[8]),
                                         cos(q3/num_iterations * params[9]),
                                         cos(q4/num_iterations * params[10])   );

                    return;

                }
 
                else if (params[60] == 6.0) {

                    //this sucks
                    vec3 b = vec3(vPosition.x,vPosition.y,float(escape_value));
                    vec3 a = vec3(new_x,new_y,log(final_r));
  
                    vec3 crx = cross(a,b);
                    float mag = dot(crx,crx);

                    gl_FragColor = vec4( sin(params[43]*crx.z), 0.0, 0.0, 1.0);
                    return;

                }

                else {
                    x1b    = sin( lx1 * params[7]) ;
                    y1b    = sin( ly1 * params[8]) ;
                    angle2 = sin( angle*params[9]) ;

                    // if we are using texture then we want x1b, y1b, angle to have signs
                    if ( params[61] != 3.0 ) {
                        x1b *= x1b;
                        y1b *= y1b;
                        angle2 *= angle2;
                    }
                }
                 
                float sgn_x1 = new_x < 0.0 ? -1.0 : 1.0;
                float sgn_y1 = new_y < 0.0 ? -1.0 : 1.0;
          
                float r,g,b,r2,g2,b2,r3,g3,b3,rx,gx,bx;
                float hue,s,l;

                //pc for primary color
                pc = ((log(ev)));
 
                if ( params[42] != 0.0 ) {
                    pc =  ev - params[42] * log( potential / log_2 / params[43] ) / log_2;
                    //follows is the official potential function
                    //multiply by .5 since final_r is actually the square of the value we want
                    //pc =  .5 * log( final_r ) / pow(2.0, ev);
                    //pc = -log(pc) * params[43];
                }

                float p1,p2,p3;

                //this is painful
                if      (params[22]==0.0) {p1=x1b;}
                else if (params[22]==1.0) {p1=y1b;}
                else if (params[22]==2.0) {p1=angle2;}
        
                if      (params[23]==0.0) {p2=x1b;}
                else if (params[23]==1.0) {p2=y1b;}
                else if (params[23]==2.0) {p2=angle2;}

                if      (params[24]==0.0) {p3=x1b;}
                else if (params[24]==1.0) {p3=y1b;}
                else if (params[24]==2.0) {p3=angle2;}

                //for hue frequency it would be nice to be able to restrict 
                //it to smaller subsets than roygbiv
                hue   = sin(pc*params[3]  +  p1 );
                s     = sin(pc*params[10] +  p2 + params[20] ); 
                l     = sin(pc*params[11] +  p3 + params[21] );               
       
                hue *= hue;
                s *= s;
                l *= l;

                if (params[60] == 5.0) {
                    //does no better than the optimal luminance frequency
                    {
                        l = 0.0;
                        dem = log(final_r)*sqrt(final_r)/sqrt(xder*xder+yder*yder);                        
                        if (dem < (1.0+params[57])*1e-9) {
                            l = 1. - dem*dem;
                            //this can look a lot better with some more fudgeing
                        }

                        //l += (1.0 - dem*(1.0+params[57]*1e8) );
                 
                    }
                }

                //Saturation and Luminance Offset
                //not sure yet if it makes more sense to put it as phase shift in the sin
                //or apply it after the sin
                //s   += params[20];
                //l   += params[21];

                //the following maps the hue to just 2 separate ranges which can create a less
                //gaudy mix of colors, depends on hue frequency, have to set hue freq high
                if (params[36] > 0.0) {
      
                    float hue1_width = max( abs(params[38] - params[37]), .001); 
                    float hue2_width = max( abs(params[40] - params[39]), .001);
                                                  
                    if (hue < params[36]) {
                        //map it to the first hue range
                        if ( params[38] > params[37] ) {
                            hue = hue * hue1_width / params[36] + params[37];
                        }
                        else {
                            //reversing the direction in the spectrum
                            hue = params[37] - hue*hue1_width / params[36];
                        }   
                    }
                    else {
                        //map it to the second hue range
                        if (params[40] > params[39]) {
                            hue = (hue-hue2_width)*hue2_width / (1.0-params[36]) + params[39];
                        }
                        else {
                            hue = params[39] - (hue-hue2_width)*hue2_width / (1.0-params[36]);
                        }
                        s = sin(pc*params[48] + p2 + params[49]);
                        l = sin(pc*params[46] + p3 + params[47]);
                        s *= s;
                        l *= l;
                        
                        //s += params[49];
                        //l += params[47];                   
                    }
                }
                else {
                    //only hue shift if we are not doing the color breakpoint thing
                    hue += params[19];
                }

                vec3 rgb, rgb2;
                if (params[34] == 1.0 || params[34] == 2.0) {
                    //this is a pleasing legacy color scheme that I like to keep around
                    rgb = vec3(  (.3+params[3])*hue + .1*angle2 + (.6+params[10])*x1b,
                                 (.3+params[3])*hue + .1*angle2 + (.6+params[11])*y1b,
                                 (.8+params[3])*hue + .2*angle2 );

                    hue += params[14];
                  
                    if (params[34] == 2.0 && sgn_x1*sgn_y1>0.0 ) {
                        rgb2 = vec3( (.3+params[3])*hue + .1*angle2 + (.6+params[10])*y1b,
                                     (.3+params[3])*hue + .1*angle2 + (.6+params[11])*x1b,
                                     (.8+params[3])*hue + .2*angle2 );
                        save_rgb = rgb2;
                    }
                    else {
                        save_rgb = rgb;
                    }

                }
                else if (params[34] == 3.0) {
                    //if the Julia_Color_Type is 3 then apply the new rotation process
                    rgb.x = jcostheta*jcospsi*(x1b) + (jsintheta*jsinphi*jcospsi+jcostheta*jsinpsi)*y1b + (-jsintheta*jcosphi*jcospsi+jsinphi*jsinpsi)*angle2;
                    rgb.y = -jcostheta*jsinpsi*x1b + (-jsintheta*jsinphi*jsinpsi+jcosphi*jcospsi)*(y1b) + (jsintheta*jcosphi*jsinpsi+jsinphi*jcospsi)*angle2;
                    rgb.z = jsintheta*x1b - jcostheta*jsinphi*y1b + jcostheta*jcosphi*(angle2);

                    //rgb.x = jcostheta*jcospsi*(p1) + (jsintheta*jsinphi*jcospsi+jcostheta*jsinpsi)*p2 + (-jsintheta*jcosphi*jcospsi+jsinphi*jsinpsi)*p3;
                    //rgb.y = -jcostheta*jsinpsi*p1 + (-jsintheta*jsinphi*jsinpsi+jcosphi*jcospsi)*(p2) + (jsintheta*jcosphi*jsinpsi+jsinphi*jcospsi)*p3;
                    //rgb.z = jsintheta*p1 - jcostheta*jsinphi*p2 + jcostheta*jcosphi*(p3);

                    //might as well have the option of binary color shift thingy
                    if ( sgn_x1*sgn_y1 > 0.0 ) {
                        rgb2 = hsl2rgb(hue, s, l);
                    }
                    else {
                        rgb2 = hsl2rgb(hue+params[14], s, l);
                    }
 
                    //mix it with the hsl color decomposition
                    //rgb += params[50]*rgb2 / (1.0+params[50]);

                    //rgb *= params[59];

                    //save_rgb = rgb ;
                    save_rgb = params[59] * ((1.0-params[50])*rgb + params[50]*rgb2);

                }
                else {
                    rgb = hsl2rgb(hue, s, l);
                    //float binary_hue = hue + params[14];
                    //rgb2 = hsl2rgb(binary_hue, s, l);
                    if ( sgn_x1*sgn_y1 > 0.0 ) {
                        //gl_FragColor = vec4( rgb, 1.0);
                        save_rgb = rgb;
                    }
                    else {
                        //changing the alpha channel is a quick way to vary the luminance
                        //gl_FragColor = vec4( rgb2, 1.0);
                        save_rgb = hsl2rgb(hue+params[14], s, l);
                    }
              
                }

                alpha = params[65];
            }   
 	
            else {
 
                alpha = 1.0;

                if (params[25]==1.0) {
                   //lx1 and ly1 are first defined above
                   lx1 = log(max_x);  
                   ly1 = log(max_y);
                   angle = atanyx(max_y,max_x); 
                }
                else if (params[25]==2.0) {
                   float inf = 1e6;
                   lx1 = clamp(log(abs(sin(max_x))), -inf, inf);
                   ly1 = clamp(log(abs(sin(max_y))), -inf, inf);
                   angle = atanyx(max_y,max_x);
                }
                else if (params[25]==3.0) {

                    lx1 = q1;
                    ly1 = q2;
                    angle = q3;

                    /*
                    gl_FragColor = vec4( cos(q1/num_iterations * params[4]),
                                         cos(q2/num_iterations * params[5]),
                                         cos(q3/num_iterations * params[6]),
                                         1.0   );
                    return;
                    */

                }
                else if (params[25]==4.0) {
                    
                    vec2 l1 = cos(log(abs(vec2(lx1,ly1)))*vec2(.3,.15));
                    float l2 = cos(angle*.5);
                    gl_FragColor = vec4( pow( (vec3( l1, l2)),vec3(8.)), 1. );
                    return;
                    
                }
                
                float x1 = sin(lx1*params[4]);
                float y1 = sin(ly1*params[5]);
	          x1  *= x1;
                y1  *= y1;
                angle = sin(angle*params[6]);
                angle *= angle;
                 
                if (params[28]==0.0) {
                    //gl_FragColor = vec4( x1, y1, angle, 1.0);
                    save_rgb.x = x1;
                    save_rgb.y = y1; 
                    save_rgb.z = angle;
 
                    save_rgb.x *= params[58];
                    save_rgb.y *= params[58];
                    save_rgb.z *= params[58];

                }
                else if (params[28]==1.0) {
                    //save_rgb.x = .77*(x1 + .3*x1);
                    //save_rgb.y = .77*(x1 + .3*y1);
                    //save_rgb.z = .50*(y1 + angle); 

                    save_rgb.x = .50*(x1 + angle);
                    save_rgb.y = .50*(x1 + y1);
                    save_rgb.z = .50*(y1 + angle); 
                }
                else if (params[28]==2.0) {
                    //if the Fatou_RGB param is 2.0 then apply the new rotation process
                    //can we get the mixture as defined for params[28]==1 using the color mix angles?  not sure
                    save_rgb.x = costheta*cospsi*x1 + (sintheta*sinphi*cospsi+costheta*sinpsi)*y1 + (-sintheta*cosphi*cospsi+sinphi*sinpsi)*angle;
                    save_rgb.y = -costheta*sinpsi*x1 + (-sintheta*sinphi*sinpsi+cosphi*cospsi)*y1 + (sintheta*cosphi*sinpsi+sinphi*cospsi)*angle;
                    save_rgb.z = sintheta*x1 - costheta*sinphi*y1 + costheta*cosphi*angle;

                    save_rgb.x *= params[58];
                    save_rgb.y *= params[58];
                    save_rgb.z *= params[58];
 
                }
                else if (params[28]==3.0) {
                    save_rgb.x = (params[58]+params[51])*(x1 + angle);
                    save_rgb.y = (params[58]+params[52])*(x1 + y1);
                    save_rgb.z = (params[58]+params[53])*(y1 + angle); 
                }
                else {
                    
                    vec3 rgb1, rgb2, rgb3;
                    if ( params[44] == 0.0 ) {
                    
                        rgb1 = hsl2rgb(params[28]+params[29], 1.0, x1);
                        rgb2 = hsl2rgb(params[28]+params[30], 1.0, y1);
                        rgb3 = hsl2rgb(params[28]+params[31], 1.0, angle);
                    
                    }
                    else if ( params[44] > 0.0 ) {
        
                        //allow params[44] to also change the saturation
                        /*
                        rgb1 = hsl2rgb(x1,    params[44], params[28]+params[29] );
                        rgb2 = hsl2rgb(y1,    params[44], params[28]+params[30] );
                        rgb3 = hsl2rgb(angle, params[44], params[28]+params[31] );
                        */

                        rgb1 = vec3( x1 , y1, angle );
                        rgb2 = hsl2rgb( x1 + y1 + angle, params[44], params[28] );
                        rgb3 = hsl2rgb( x1*params[29] + y1*params[30] + angle*params[31], 1.0, .50 );
                                        
                    }
                    else {
                        //make the Fatou region colors greyscale only
                        float lum = x1 + params[29];
                        rgb1.x = lum; rgb1.y = lum; rgb1.z = lum;
                        lum = y1 + params[30];
                        rgb2.x = lum; rgb2.y = lum; rgb2.z = lum;
                        lum = angle + params[31];
                        rgb3.x = lum; rgb3.y = lum; rgb3.z = lum;
                    }
 
                    /*
                    gl_FragColor = vec4( one_third*(rgb1.x+rgb2.x+rgb3.x),
                                         one_third*(rgb1.y+rgb2.y+rgb3.y),
                                         one_third*(rgb1.z+rgb2.z+rgb3.z), 1.0);
                    */

                    save_rgb.x = one_third*(rgb1.x+rgb2.x+rgb3.x);
                    save_rgb.y = one_third*(rgb1.y+rgb2.y+rgb3.y);
                    save_rgb.z = one_third*(rgb1.z+rgb2.z+rgb3.z);
                }
            }
         
            if ( params[61] > 0.0 ) {

                vec2 texcoord;
                if ( params[61] == 1.0 ) {
                    texcoord.x = params[62] + save_rgb.x; 
                    texcoord.y = params[63] + save_rgb.y;
                    gl_FragColor =  texture2D(texture1, texcoord);
                    gl_FragColor *= 1.0+params[46];
                }
                else if ( params[61] == 2.0 ) {
                    float r = sin(params[11]*pc + params[21]);
                    texcoord.x = .5 + params[62] + .5 * r * cos( angle2 );
                    texcoord.y = .5 + params[63] + .5 * r * sin( angle2 );
                    gl_FragColor = texture2D(texture1, texcoord);
                }
                else if ( params[61] == 3.0) {
                    texcoord.x = .5 + params[62] +  .5 * x1b;
                    texcoord.y = .5 + params[63] +  .5 * y1b;
                    gl_FragColor = texture2D(texture1, texcoord);
                    gl_FragColor.x += angle2;
                    gl_FragColor.y += angle2;
                    gl_FragColor.z += angle2;
                }
                else if ( params[61] == 4.0) {
                    float orig_angle = atanyx(vPosition.y,vPosition.x);
                    float r = sin(params[11]*pc + params[21]);
                    texcoord.x = .5 + params[62] + .5 * r * cos( orig_angle );
                    texcoord.y = .5 + params[63] + .5 * r * sin( orig_angle ); 
                    gl_FragColor = texture2D(texture1, texcoord);                   
                }
            }
            else {

                if ( params[44] < -1.0 ) {
                    //round colors to black and white
                    float red, green, blue;
                    float c1 = 1.0, c2 = 0.0;
                    if ( params[44] < -2.0 ) {
                        //reverse the black and white
                        c1 = 0.0; c2 = 1.0;
                    }
                    if ( save_rgb.x > params[28] ) {
                        red = c1; green = c1; blue = c1;
                    }
                    else {
                        red = c2; green = c2; blue = c2;
                    }
                    gl_FragColor = vec4( red, green, blue, 1.0 );   
                }
                else { 
                    //different regions may have different alphas
                    gl_FragColor = vec4( save_rgb.x, save_rgb.y, save_rgb.z, alpha );
                }
            }

    }
	
    //END OF GPU PROGRAM

</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec2        aVertexPosition;
    attribute vec2        aPlotPosition;
    varying   vec2        vPosition;
      

    //START OF GPU PROGRAM       
    void main(void) {
        //aVertexPosition always fills in a square that is -1 to 1 on both x and y
        //that gets mapped to the corners of the canvas window
        gl_Position = vec4(aVertexPosition, 1.0, 1.0);

        //aPlotPosition is a moveable and rescaleable square in the complex plane
        vPosition = aPlotPosition;  

        //both aVertexPosition and aPlotPosition are the same size grid determined
        //by the height and width of the canvas is pixels
        //aPlotPosition is the "real" world coordinate, aVertexPosition is the internal "clipspace" coordinate
    }
    //END OF GPU PROGRAM
</script>


<!-- Shader program for the on-screen image -->

<script type="x-shader/x-vertex" id="vshader">

    attribute vec2   a_coords;
    attribute vec2   a_texCoords;
    varying   vec2   v_texCoords;

    void main() {
 
        //we really only need v_texcoords to be filled in here
        //not really interested in 3d transformations of 2d fractal images for now

        gl_Position       = vec4(a_coords, 0.0, 1.0);
        v_texCoords       = a_texCoords;
    }

</script>

<script type="x-shader/x-fragment" id="fshader">
    #ifdef GL_FRAGMENT_PRECISION_HIGH
       precision highp float;
    #else
       precision mediump float;
    #endif

    uniform sampler2D   texture;
    varying vec2        v_texCoords;

    uniform   float     params[67];
    uniform   float     mouse_coords[12];
    //uniforms are constant junk coming in from javascript or whatever lang is linked to gl shaders
    uniform   float     offset_x[25];
    uniform   float     offset_y[25];
    uniform   float     offset_weights[25];
    uniform   float     offset_params[2];
    // 0 : sum of weights, 1 : size of pixel in texture map 
    // offset_params[1] contains the offset for one pixel in the texture map

    void main() {

      if ( params[66] == 1.0 || params[66] == 4.0) {
        //offset_weights contain a 2d gaussian kernel, in other words weights from under a normal distribution        
        vec4 total_color = vec4(0.0,0.0,0.0,0.0);
        float one_pixel = offset_params[1]/(1.0+params[10]);
        float sqrt_2 = sqrt(2.0);
        float green = 0.0;
        for (int i=0; i<5; i++) {
            for (int j=0; j<5; j++) {
                                
                float  pix = one_pixel/sqrt_2;
                //vec4 x2 =  texture2D(texture, v_texCoords+vec2( one_pixel, one_pixel  ) + vec2( i-2,j-2 ) * one_pixel); 
                vec4 x2 =  texture2D(texture, v_texCoords+vec2( 0.0,  one_pixel) + vec2( i-2,j-2 ) * one_pixel);
                vec4 x3 =  texture2D(texture, v_texCoords+vec2( pix, pix) + vec2( i-2,j-2 ) * one_pixel);
                vec4 x4 =  texture2D(texture, v_texCoords+vec2( 0.0, -one_pixel) + vec2( i-2,j-2 ) * one_pixel);

                //cross product of x2 and x3 in x,y,w
                float a = x3.x*x2.y - x3.y*x2.x;
                float c = x3.x*x2.w - x3.w*x2.x;
                float e = x3.y*x2.w - x3.w*x2.y;

                //adding in the other components of the wedge product results in garbage
                //1 component of the wedge product of x2,x3,x4
                green += offset_weights[i*5 + j] * ( (a*x4.w - c*x4.y + e*x4.x) ) ;
            }
        }

        float  xxx = .2 - green*100.0*params[11] * mouse_coords[11];
        vec4 actual_pixel = texture2D(texture, v_texCoords);
        float extra_light = 0.0;
        if ( actual_pixel.z == 0.0 ) extra_light = .02;

        float yyy = ( xxx - extra_light);

        gl_FragColor = vec4( yyy, yyy/2.0+sin(params[57]*actual_pixel.z)/2.0,yyy, params[65]);
        return;

      }
 
      else if (params[66] == 3.0) {
        float one_pixel = offset_params[1]/(1.0+params[10]);
        float sum=0.0;
        for (int i=0; i<3; i++) {
          for (int j=0; j<3; j++) {
            vec4 color = texture2D(texture, v_texCoords+vec2(i-1,j-1)*one_pixel);
            // if we set it to black and white all x,y,z are all 0 or 1
            sum += color.x;   
          }
        }
        if (sum > (0.0+params[57]) && sum < (9.0-params[57]) ) {
           //if it is on the border
           gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        }
        else {
           gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
        
      }    
   
      else if (params[66] == 0.0) {

        gl_FragColor = texture2D(texture, v_texCoords);
        return;
      } 
 
      else if (params[66] == 2.0) {

        //offset_weights contain a 2d gaussian kernel        
        vec4 total_color = vec4(0.0,0.0,0.0,0.0);
        for (int i=0; i<5; i++) {
            float fi = float(i);
            for (int j=0; j<5; j++) {
                vec4 color = texture2D(texture, v_texCoords + vec2( fi-2.0,float(j)-2.0 ) * offset_params[1] );
                total_color += color * offset_weights[i*5 + j];
            }
        }
        //weights are normalized
        gl_FragColor = total_color;
        
      }  

      else if (params[66] == 6.0) {

        vec4 check_color = texture2D(texture, v_texCoords);
     
        if ( (abs(check_color.x) + abs(check_color.y) + abs(check_color).z) < (1. + params[57]) ) {
            //gl_FragColor = vec4(1.);

        //get the brightest color that is nearby
        vec4 max_color = vec4(1.0,1.0,1.0,1.0);
        vec3 total_color = vec3(0.);
        float num_tc = 0.;
        float max_tc = 0.;
        for (int i=0; i<5; i++) {
            float fi = float(i);
            for (int j=0; j<5; j++) {
                vec4 color = texture2D(texture, v_texCoords + vec2( fi-2.0,float(j)-2.0 ) * offset_params[1] );
                float tc = abs(color.x) + abs(color.y) + abs(color.z);

                //max color gives a nice but different effect
                
                if (tc > max_tc) { 
                    max_tc = tc;
                    max_color = color;
                }
                     
                if (tc >= 1.2 ) {
                    total_color += color.xyz;
                    num_tc ++;
                }
         
            }
         }
 
         total_color /= num_tc;
         float check_total = abs(total_color.x) + abs(total_color.y) + abs(total_color.z);
         if (check_total < .2) total_color = max_color.xyz; 
         gl_FragColor = vec4( total_color, 1.);
         //gl_FragColor = max_color * (1.+params[32]);

       }
            
       else {
        //offset_weights contain a 2d gaussian kernel        
        vec4 total_color = vec4(0.0,0.0,0.0,0.0);
        for (int i=0; i<5; i++) {
            float fi = float(i);
            for (int j=0; j<5; j++) {
                vec4 color = texture2D(texture, v_texCoords + vec2( fi-2.0,float(j)-2.0 ) * offset_params[1] );
                total_color += color * offset_weights[i*5 + j];
            }
        }
        //weights are normalized
        gl_FragColor = total_color;
       }
     
      }

      else if (params[66] == 7.0) {

        vec3 total_color = vec3(0.);
        vec3 alt_color = vec3(0.);
        float alt_weight = 0.;
 
        vec4 brightest_color = vec4(0.);
        float num_tc = 0.;
        float max_tc = 0.;

        for (int i=0; i<5; i++) {
            float fi = float(i);
            for (int j=0; j<5; j++) {

                float weight = offset_weights[i*5 + j];
                vec4 color = texture2D(texture, v_texCoords + vec2( fi-2.0,float(j)-2.0 ) * offset_params[1] );
                float tc = abs(color.x) + abs(color.y) + abs(color.z);
                if (tc > max_tc) {
                    brightest_color = color;
                    max_tc = tc;
                }
 
                if (tc > (1. + params[57])*.8 ) {
                    alt_color += color.xyz * weight;
                    alt_weight += weight;
                }

                total_color += color.xyz * weight;
            }
        }

        float final_tc = abs(total_color.x) + abs(total_color.y) + abs(total_color.z);
        float final_alt_tc = abs(alt_color.x) + abs(alt_color.y) + abs(alt_color.z);
        float final_max_tc = abs(brightest_color.x) + abs(brightest_color.y) + abs(brightest_color.z);

        if ( final_tc < ( 1. + params[57] ) ) {
            if ( final_alt_tc > .5 ) {
                total_color = alt_color / alt_weight;   //brightest_color.xyz;
            }
            else if ( final_max_tc > .5 ) {
                total_color = brightest_color.xyz * .9;
            }
            else {
                total_color = vec3( .3 );
            }
            //total_color *= .9;
        }

        gl_FragColor = vec4( total_color, 1.0 );

      }

        
      else if (params[66] == 5.0) {
                
        vec4 total_color = vec4(0.0,0.0,0.0,0.0);

        float total_weight = 0.0;
        for (int i=0; i<25; ++i) { 
            vec4 color = texture2D(texture, v_texCoords + vec2(offset_x[i],offset_y[i]) * offset_params[1]/(1.+params[57]) );
            float weight = 1.0 / exp(float(i)/(1.0+params[45]));
            total_color += color * weight;
            total_weight += weight;
        }

        gl_FragColor = total_color / total_weight;   //offset_params[0];
         
  
       }
       
       
    }

</script>

<script src="texture_map_images.js"></script>

<script type="text/javascript">
    // main inline js follows
    // window.location.href is the url of this page

    const preLoaded = [

//cosmic jungle
[{"scene_number":0,"center_x":-1.4607403147358324,"center_y":-0.28111109769082393,"width":0.010898949004519718,"height":0.007225394619239964,"total_zoom":276.8014904922065,"param_details":["1200","0.6659999999999997","1e9","0","0","0","0","26","-18","56","0","0","1","1","0","0","1","0","0","0.6","1","0","0","2","1","0","0","0","0","0","0","0","0.01","1","4","0","0","0.13","0.15","0.6","0.62","1","1","6","0","0","0.1","0","0","1","0","0","0","0","0","0","0","0","1.9000000000000008","3.300000000000002","4","0","0","0","0","5","2"],"mouse_coords":[-0.8802083333333334,0.980246913580247,-1,-1.4703336604741857,-0.2740284269159146,0.010898949004519718,0.007225394619239964,1536,810,0,0,276.8014904922065],"doing_julia":0}],

//logz rings
[{"scene_number":0,"center_x":0,"center_y":0,"width":0.00022044168996840987,"height":0.00009912672071782087,"total_zoom":20176.194526734133,"param_details":["46","1","10000","0","0.3300000000000001","0.22000000000000006","0.20000000000000004","0","0","0","0","0.035","1","1","0","17","0.99","0","1","0.6","1","0","0","2","1","0","0","0","0","0","0","0","0.01","1","0","0","0","0.13","0.15","0.6","0.62","1","1","6","0","0","0.1","0","0","1","0","0","0","0","0","0","0","0","1","1","0","0","0","0","0","1","0"],"mouse_coords":[-0.9058823529411765,0.9825581395348837,-1,-0.00019969423679491247,0.00009739776628669609,0.00022044168996840987,0.00009912672071782087,1530,688,0,0,20176.194526734133],"doing_julia":1}],

//pastel colors
[{"scene_number":0,"center_x":-0.03545077880929693,"center_y":0.026588084106972693,"width":4.781608579088447,"height":2.6619999999999857,"total_zoom":0.7513148009015816,"param_details":["36","0","1e9","0","0.4499999999999995","0.28999999999999937","0.5000000000000002","0","0","0","0","0","1","1","0","2","-1.790000000000002","0","1","0.6","1","0","0","2","1","0","0","0","2","2","0","0","0.01","1","0","0","0","0.13","0.15","0.6","0.62","1","1","6","0","0","0.1","0","0","1","0","9.399999999999988","3.8999999999999995","35.500000000000234","0","0","0","0","1.2999999999999994","1","0","0","0","0","0","3","2"],"mouse_coords":[-0.18208955223880596,0.13207547169811318,-1,-0.9061317439567455,0.37817298976734803,4.781608579088447,2.6619999999999857,1340,689,0,0,0.7513148009015816],"doing_julia":1}],

//exp laser
[{"scene_number":0,"center_x":-0.908002295697399,"center_y":0.0010283189714411045,"width":0.3739668385521625,"height":0.20305119598953955,"total_zoom":9.849732675807712,"param_details":["83","0.494","1e38","0","0","0.13999999999999999","0.5000000000000002","0","0","0","0","0","1","1","0","8","0.8891253500064195","4.646484272894102","0","0.6","0","0","0","2","1","0","0","0","2","0","0","0","0.01","1","0","0","0","0.13","0.15","0.6","0.62","1","0","6","1","1","0.1","0","0","1","0","2.800000000000001","2.400000000000001","0.20000000000000015","0","0","0","0","1.5000000000000007","1","0","0","0","0","0","1","2"],"mouse_coords":[-0.9437262357414449,1,-1,-1.26092461253636,0.20407951496098065,0.3739668385521625,0.20305119598953955,1315,656,-0.05855513307984794,-0.8871951219512195,9.849732675807712],"doing_julia":0}],

//sunrise
[{"scene_number":0,"center_x":2.3237985262259095,"center_y":1.844565752664064,"width":0.0010962774740611555,"height":0.0005010330643170132,"total_zoom":3991.7525258064884,"param_details":["1609","0.02847999999999918","1e6","0","0","0","0","-51.09999999999999","-12.699999999999998","70","0","0","1","1","0","0","0.4619867279240067","4.244558541874834","1","0.6","1","0","0","2","1","0","0","0","0","0","0","0","0.01","1","0","0","0","0.13","0.15","0.6","0.62","1","1","6","0","0","0.1","0","0","1","0","0","0","0","0","0","0","0","0","0","4","0","0","0","0","1","2"],"mouse_coords":[-0.5809523809523809,0.053968253968254,-1,2.3231616412171694,1.8445927925437255,0.0010962774740611555,0.0005010330643170132,1155,630,-0.20833333333333337,-0.41234567901234565,3991.7525258064884],"doing_julia":1}],

//alien corpse
[{"scene_number":0,"center_x":625.2808826171464,"center_y":12.671307899753533,"width":713.2406674523336,"height":457.5231247804526,"total_zoom":0.004371363744640723,"param_details":["211","1.848180000000003","1e6","0","0","0","0","12.199999999999978","19.300000000000033","0","0","0","1","1","0","0","1","0","0","0.6","1","0","0","2","1","0","1","0","0","0","0","0","0.01","0","5","0","0","0.13","0.15","0.6","0.62","1","1","6","0","0","0.1","0","0","1","0","0","0","0","0","0","0","0","1","1","4","0","0","0","0","1","2"],"mouse_coords":[-0.7130584192439863,0.9783616692426584,-1,116.69861974305974,460.2943959770742,713.2406674523336,457.5231247804526,1164,647,0,0,0.004371363744640723],"doing_julia":0}],

//black and white 01
[{"scene_number":0,"center_x":-25.268682772856877,"center_y":-101.5296208556008,"width":3576.723953498708,"height":2102.3063990000214,"total_zoom":0.0009513361139705009,"param_details":["5","0.0007179999999999984","8e9","0","0","0.47000000000000025","0.3500000000000001","0","0","0","0","0","1","1","0","1","0.7894805827869273","1.0428480056302758","1","0.6","1","0","0","2","1","0","1","0","0.34000000000000014","0","0","0","0.01","1","0","0","0","0.13","0.15","0.6","0.62","1","1","6","-3","0","0.1","0","0","1","0","2","3","0","0","0","0","0","1","1","0","0","0","0","0","1","2"],"mouse_coords":[-0.48669796557120504,0.2545454545454545,-1,-1766.0529543504754,433.6029170716773,3576.723953498708,2102.3063990000214,1278,660,0.39655172413793105,0.6799999999999999,0.0009513361139705009],"doing_julia":1}],

//nice spiral
[{"scene_number":0,"center_x":-0.7438197734814914,"center_y":0.12450656077757284,"width":0.00018698172308140342,"height":0.00011994333206856068,"total_zoom":16674.54093118559,"param_details":["950","1","1e37","0","0","0","0","51.800000000000054","46","75","0","1","1","1","0","1","1","0","0","0.6","1","0","0","2","1","0","0","0","0","0","0","0","0.01","0","4","0","0","0.13","0.15","0.6","0.62","1","1","6","0","0","0.1","0","0","1","0","0","0","0","0","0","0","0","1","1","4","0","0","0","0","1","2"],"mouse_coords":[-0.8727445394112061,0.9937205651491365,-1,-0.7439829607592804,0.12462575093330189,0.00018698172308140342,0.00011994333206856068,1053,637,0,0,16674.54093118559],"doing_julia":0}],

//boxy
[{"scene_number":0,"center_x":-0.34904618700051265,"center_y":-89.99037354627376,"width":79.83939212422311,"height":42.22755349070222,"total_zoom":0.04736244074477026,"param_details":["85","1.0001740000000048","1e9","0","1","1","1","0","0","0","0","0.01","1","1","0","25","0.01831593192814926","6.8816929141122944","1","0.6","1","0","0","2","1","0","2","0","2","0","0","0","0.01","1","0","0","0","0.13","0.15","0.6","0.62","1","1","6","0","0","0.1","0","0","1","0","6.199999999999995","11.599999999999975","1.9000000000000008","-0.1","-2.7755575615628914e-17","0","0","2","1","0","0","-2.300000000000001","-2.700000000000001","0","1","0"],"mouse_coords":[-0.0022573363431150906,0.18991097922848665,-1,-0.5292705484547382,-81.97089751243121,79.83939212422311,42.22755349070222,1329,674,0.00868055555555558,0.015923566878980888,0.04736244074477026],"doing_julia":1}],

//icy sky
[{"scene_number":0,"center_x":238.8562363107144,"center_y":-180.57784530809474,"width":149.66412920839775,"height":82.28955557850071,"total_zoom":0.02430442096739829,"param_details":["200","1.846180000000003","1e4","0","0","0","0","-8.199999999999989","-7.199999999999991","0","0","0","1","1","0","0","0.7828580730775535","0.2790401651273198","1","0.6","1","0","0","2","1","0","1","0","0","0","0","0","0.01","0","0","0","0","0.13","0.15","0.6","0.62","1","1","6","0","0","0.1","0","0","1","0","0","0","0","0","0","0","0","1","1","4","0","0","0","0","1","2"],"mouse_coords":[-0.5945017182130584,0.778125,-1,149.88065434146074,-116.54628487357388,149.66412920839775,82.28955557850071,1164,640,0.7525773195876289,0.21562499999999996,0.02430442096739829],"doing_julia":1}],

//inside out newton
[{"scene_number":0,"center_x":-12.454013295699951,"center_y":-4.182113123652147,"width":151685.88124993956,"height":78635.39057434277,"total_zoom":0.000025433840734970068,"param_details":["24","0.9876000000000003","1e12","0","0","0","0.5000000000000002","0","0","0","0","0","1","1","0","19","0.031084060755427467","-4.293362470280972","1","0.6","1","0","0","2","1","0","1","0","0.2800000000000001","0","0","0","0.0009999999999999697","0","0","0","0","0.13","0.15","0.6","0.62","1","1","6","-3","0","0.1","0","0","1","0","0.09999999999999981","0","0","0","0","0","-2.400000000000001","1","1","0","0","0","0","0","1","2"],"mouse_coords":[-0.9951020408163266,0.8266068759342302,-1,-150955.38400813352,64996.372427401846,151685.88124993956,78635.39057434277,1225,669,-0.010309278350515427,-0.012345679012345734,0.000025433840734970068],"doing_julia":1}],

//pure beauty
[{"scene_number":0,"center_x":-1.4406059037584054,"center_y":-0.3116886793294082,"width":0.0034727410334936294,"height":0.0023022333958084657,"total_zoom":868.7216524794019,"param_details":["800","0.6679999999999997","1e12","0","0","0","0","-39.2","-48","-84","0","0","1","1","0","0","1","0","0","0.6","1","0","0","2","1","0","0","0","0","0","0","0","0.01","1","0","0","0","0.13","0.15","0.6","0.62","1","1","6","0","0","0.1","0","0","1","0","0","0","0","0","0","0","0","1","1","4","0","0","0","0","1","2"],"mouse_coords":[-1,1,-1,-1.444078644791899,-0.3093864459335997,0.0034727410334936294,0.0023022333958084657,1536,859,0,0,868.7216524794019],"doing_julia":0}],

//stone carving
[{"scene_number":0,"center_x":-28870.95212448154,"center_y":-38937.512276949994,"width":7465.175115722972,"height":4772.33808258661,"total_zoom":0.000419081792905167,"param_details":["170","1.0900000000000007","1e6","0","1","1","1","0","0","0","0.07999999999999997","-0.00006999999999999703","1","1","0","17","0.8963740740740765","0","1","0","1","0.05","0","2","1","0","2","0","2","0","0","0","0.01","1","0","0","0","0.13","0.15","0.6","0.62","2.300000000000001","1","6","0","0","0.1","0","0","1","0","-1.9000000000000017","13.799999999999967","-4.6","0","0","0","0.8999999999999997","1.2000000000000004","1","0","0","0","0","0","1","1"],"mouse_coords":[-0.9478827361563518,0.8930041152263375,-1,-35947.06273905934,-34675.794729948786,7465.175115722972,4772.33808258661,1228,729,0.41481481481481475,0,0.000419081792905167],"doing_julia":1}],

//strange
[{"scene_number":0,"center_x":38105.715464760644,"center_y":-17525.1938136392,"width":2162.3953195215668,"height":1382.376350586167,"total_zoom":0.001446784010122816,"param_details":["496","1.0668400000000058","1e8","0","7.670000000000007","1.6100000000000005","2.2599999999999945","0","0","0","1","-0.002910000000000014","1","1","0","17","0.7860740740740741","0","1","0","1","0.05","0","2","1","0","2","0","2","0","0","0","0.01","1","0","0","0","0.13","0.15","0.6","0.62","2.300000000000001","1","6","0","0","0.1","0","0","1","0","-1.9000000000000017","13.799999999999967","-4.6","0","0","0","46.000000000000384","0.9999999999999999","1","0","0","4.300000000000001","-2.600000000000001","0","1","1"],"mouse_coords":[-0.9299674267100977,0.7805212620027435,-1,36094.758253935215,-16446.219679916936,2162.3953195215668,1382.376350586167,1228,729,0.41481481481481475,0,0.001446784010122816],"doing_julia":1}]

    ];

    var pi              = 3.141592650;
    var pi_over_2       = 1.570796325;
    var three_pi_over_2 = 4.712388975;
    var two_pi          = 6.303185300;

    // what the hell are querySelectors for?
    var container = document.querySelector('#save_file');
    var output = container.querySelector('output');
    const MIME_TYPE = 'text/plain';

    //WE SHOULD JUST MAKE THIS A HASH MAP 
    var params = ["Max_Iter"/*0*/,"Mix_Factor"/*1*/,"Infinity"/*2*/,"Hue_Freq"/*3*/,
                  "Fatou_Real_Freq"/*4*/,"Fatou_Imag_Freq"/*5*/,"Fatou_Angle_Freq"/*6*/,
                  "Julia_Real_Freq 0"/*7*/,"Julia_Imag_Freq 1"/*8*/,"Julia_Angle_Freq 2"/*9*/,
                  "Saturation_Freq"/*10*/,"Luminance_Freq"/*11*/,
                  "Real_Modz_Param"/*12*/,"Imag_Modz_Param"/*13*/,"Binary_Color_Shift"/*14*/,
                  "Function_#"/*15*/,"Param_Radius"/*16*/,"Param_Angle"/*17*/,"Mandel_Julia"/*18*/,
                  "Hue_Shift"/*19*/,"Saturation_Shift"/*20*/,"Luminance_Shift"/*21*/,
                  "Hue_P1"/*22*/,"Sat_P2"/*23*/,"Lum_P3"/*24*/,
                  "Fatou_Color_Type"/*25*/,"Invert"/*26*/,"Tile"/*27*/,"Fatou_RGB"/*28*/,
                  "Fatou_Hue1"/*29*/,"Fatou_Hue2"/*30*/,"Fatou_Hue3"/*31*/,"Epsilon"/*32*/,
                  "Newton_Color"/*33*/,"Julia_Color_Type"/*34*/,"Invert_At_Mouse"/*35*/,
                  "Color_BP"/*36*/,"Hue1_Min"/*37*/,"Hue1_Max"/*38*/,"Hue2_Min"/*39*/,"Hue2_Max"/*40*/,
                  "Julia_Param_Mult"/*41*/,"Potential_Mult"/*42*/,"Potential_Exp"/*43*/,"Fatou_RGB_Type"/*44*/,
                  "AntiAlias_Mult"/*45*/,"Lum_Freq_2"/*46*/,"Sat_Freq_2"/*47*/,"Lum_Off_2"/*48*/,"Sat_Off_2"/*49*/,
                  "Julia_RGB_HSL"/*50*/,"Fatou_Theta"/*51*/,"Fatou_Phi"/*52*/,"Fatou_Psi"/*53*/,
                  "Julia_Theta"/*54*/,"Julia_Phi"/*55*/,"Julia_Psi"/*56*/,
                  "Z"/*57*/,"Fatou_Luminance"/*58*/,"Julia_Luminance"/*59*/,"X1B_Type"/*60*/,"Texture"/*61*/,
                  "Tex_X_Offset"/*62*/,"Tex_Y_Offset"/*63*/,"Julia_Toggle"/*64*/,"Julia_Alpha"/*65*/,
                  "Pseudo_3d"/*66*/];
                             

    //                              0,     1,       2,    3,    4,    5,    6,    7,    8,    9,   10,   
    var initial_values       = [200.0,   1.0, 10000.0, 0.00, 0.00, 0.00, 0.50, 0.00, 0.00,  0.0, 0.00,

    //                             11,    12,  13,   14,   15,   16,   17,   18,   19,   20,   21,   22,  
                                 .035,   1.0, 1.0, 0.00,  1.0,  1.0,  0.0,  0.0, 0.60, 1.00, 0.00,    0,

    //                             23,   24, 25,   26, 27,   28,   29,   30,   31,   32,   33,   34,
                                    2,   1,   0,    0,  0, 0.00, 0.00, 0.00, 0.00, 0.01,  1.0,    0,

    //                             35,   36,  37,   38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50  
                                    0, 0.00, .13,  .15,  .6, .62, 1.0, 1.0, 6.0,   0, 0.0, 0.1, 0.0, 0.0, 1.0, 0.0,

    //                             51,   52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65, 66
                                  0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0,   0, 0.0, 0.0,   0, 1.0,  0];

    //                              0,     1,       2,    3,    4,    5,    6,    7,    8,    9,   10, 
    var param_default_deltas = [  1.0, 0.002,  1000.0, 0.01, 0.01, 0.01, 0.01, 0.10, 0.10, 0.10, 0.01,

    //                             11,    12,  13,   14,   15,   16,   17,   18,   19,   20,   21,   22, 
                                 0.01,   .01, .01, 0.01,    1,  .01,  .01,  1.0, 0.01, 0.01, 0.01,    1,

    //                             23,   24, 25,   26, 27,   28,   29,   30,   31,   32,   33,   34,
                                    1,    1,  1,    1,  1, 0.01, 0.01, 0.01, 0.01, 1e-2,  0.1,    1,

    //                             35,   36,  37,   38,  39,  40,  41,  42,  43,  44,  45,   46,   47,   48,   49,   50
                                   .1, 0.01, .01,  .01, .01, .01,  .1, .01, 1.0,  .1, 0.1, 0.01, 0.01, 0.01, 0.01, 0.01,

    //                             51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65, 66
                                  0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 1.0,   1, 0.1, 0.1,   1,  .1,  1];


    //a set of points relatuve to 0,0 for calculating averages around each iterated pixel
    var offset = { "x":[],"y":[],"weights":[],"params":[],
                   "x_loc":null,"y_loc":null,"weights_loc":null,"params_loc":null,
                   "radius":4.0,"init_angle":0.0,"num_points":25.0,"winding_number":65.,"sum_weights":0.0};
 
    //http://dev.theomader.com/gaussian-kernel-calculator/
    //gaussian_kernel is just a way to take the weighted average of 25 points in a 5x5 grid centered on the current pixel
    //would prefer bilateral filter but that is too much work right now
    var gaussian_kernel_one_stdev = [
        0.003765,0.015019,0.023792,0.015019,0.003765,
        0.015019,0.059912,0.094907,0.059912,0.015019,
        0.023792,0.094907,0.150342,0.094907,0.023792,
        0.015019,0.059912,0.094907,0.059912,0.015019,
        0.003765,0.015019,0.023792,0.015019,0.003765
    ]

    var gaussian_kernel_half_stdev = [
        0.000002,0.000212,0.000922,0.000212,0.000002,
        0.000212,0.024745,0.107391,0.024745,0.000212,
        0.000922,0.107391,0.466066,0.107391,0.000922,
        0.000212,0.024745,0.107391,0.024745,0.000212,
        0.000002,0.000212,0.000922,0.000212,0.000002
    ]

    var params_location;
    var params_location2;  //to send to the on screen shader  

    var mouse_coords_loc;
    var mouse_coords_loc2; 

    //texture map coord stuff to be passed to the on screen shaders
    var a_coords_loc;
    var a_texCoords_loc; 
    var u_texture;
    var u_texture1;

    var gl;
    var prog_canvas;
    var prog_texture;

    var aVertexPosition;
    var vertexPositionBuffer;
    var texturePositionBuffer;
    var canvasPositionBuffer;
    var canvasIndexBuffer;
  
    var framebuffer;
    var texture;
    var color_map_texture;

    var zoom = [];
    //need to keep track of mandel vs julia coordinates separately
    var current_center_x = [];
    var current_center_y = [];
    var current_width    = [];
    var current_height   = [];
    var current_zoom     = [1.0,1.0];

    //toggles
    var recenter_julia_params = 0;
    var snapshot_mode = 1;
    var julia_mouse = 0;

    var aspect_ratio = 1.0;

    //vars for saving parameters for every different frame
    var zoom_save = [];
    var scene_counter = 0;
    var scene_number  = 0;

    function toggle_recenter_julia_params() {
        recenter_julia_params ^= 1;
    }
   
    function toggle_snapshot() {
        snapshot_mode ^=1;
    }

    function showSamples() {
        const div = document.getElementById("loadSampleDiv");
        div.classList.toggle("hidden");
    }

    function loadSample(ev) {
        const div = document.getElementById("loadSampleDiv");
        console.log(ev.target.id);

        const sampleNum = parseFloat( ev.target.id.split('-')[1] ) ;
        console.log(  sampleNum );

        div.classList.toggle("hidden"); 

        if (isNaN(sampleNum) ) { 
            console.log('problem with sample:',ev.target.id);  
            return 
        }
 
        //const JSON_object = JSON.parse( preLoaded[sampleNum] );
        zoom_save = preLoaded[sampleNum];
     
        document.getElementById("start_frame").valueAsNumber = 0;
        document.getElementById("scene_number").valueAsNumber = 0;
        document.getElementById("last_frame").valueAsNumber = zoom_save.length;
        scene_counter = zoom_save.length;

        scene_number = 0;
        queue_up_snapshot = 1;
        drawScene();

    }

    var queue_up_snapshot = 0;
    // this function gets called when we select a file
    function handleFileSelect(evt) {
        var files = evt.target.files; // FileList object

        var reader = new FileReader();
 
        // file read is asynch so we need to specify a function that gets called when it is done
        reader.onload = function(e) {            
            var JSON_object = JSON.parse(e.target.result);
 
            //JSON.parse produces an associative map of objects
            //we need an array of objects
            //override the original zoom_save
            //this .map is a short way of writing a loop over the keys
            zoom_save = Object.keys(JSON_object).map(function(k) { return JSON_object[k] });
 
            document.getElementById("start_frame").valueAsNumber = 0;
            document.getElementById("scene_number").valueAsNumber = 0;
            document.getElementById("last_frame").valueAsNumber = zoom_save.length;
            scene_counter = zoom_save.length;

            if (scene_counter == 1) {
                //this must have been a snapshot so queue it up
                scene_number = 0;
                queue_up_snapshot = 1;
                drawScene();
            }
            else {

                scene_number = scene_counter - 1; 
                queue_up_snapshot = 1;
                document.getElementById("start_frame").valueAsNumber = Math.max( 0, scene_number - 100);
                document.getElementById("scene_number").valueAsNumber = scene_number;
                drawScene();
            }

        }

        reader.readAsText(files[0]);   
    }

    var downloadFile = function() {

        var prevLink = output.querySelector('a');
        if (prevLink) {
            window.URL.revokeObjectURL(prevLink.href);
            output.innerHTML = '';
        }

        var bb;
        if (snapshot_mode == 1) {
            bb = new Blob([JSON.stringify(snapshot)], {type: MIME_TYPE});
        }
        else {
            bb = new Blob([JSON.stringify(zoom_save)], {type: MIME_TYPE});
        }


        var a = document.createElement('a');
        a.download = container.querySelector('input[type="text"]').value;
        a.href = window.URL.createObjectURL(bb);
        //a.textContent = 'Download Animation File';

        a.dataset.downloadurl = [MIME_TYPE, a.download, a.href].join(':');

        //a.draggable = true;
        //a.classList.add('dragout');

        output.appendChild(a);
   
        a.click();     

        /*
        a.onclick = function(e) {
    
        }
        */

        cleanUp(this);
    }

    var cleanUp = function(a) {

        //a.textContent = 'Downloaded';

        // dont understand why this is not working
        //a.dataset.disabled = true;

        // Need a small delay for the revokeObjectURL to work properly.
        setTimeout(function() {
            window.URL.revokeObjectURL(a.href);
        }, 1500);
    };

    var init_tex_size = 1024.0;
    var tex_size = init_tex_size;  //we should really make this proportional to the canvas size
                                   //although with it much larger all the time we do get nice anti aliasing automatically


    function init_Buffers() {

        params_location   = gl.getUniformLocation(prog_texture, "params");
        params_location2  = gl.getUniformLocation(prog_canvas, "params");
        mouse_coords_loc  = gl.getUniformLocation(prog_texture, "mouse_coords");
        mouse_coords_loc2 = gl.getUniformLocation(prog_canvas, "mouse_coords");
    
        aVertexPosition   = gl.getAttribLocation(prog_texture, "aVertexPosition");
        gl.enableVertexAttribArray(aVertexPosition);

        aPlotPosition     = gl.getAttribLocation(prog_texture, "aPlotPosition");
        gl.enableVertexAttribArray(aPlotPosition);

        texturePositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texturePositionBuffer);
        var tex_vertices = [
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tex_vertices), gl.STATIC_DRAW);
        texturePositionBuffer.itemSize = 2;
        texturePositionBuffer.numItems = 4;
 
        canvasPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, canvasPositionBuffer);
        var canvas_vertices = [
            -1.0, -1.0,
             1.0, -1.0,
             1.0,  1.0,
            -1.0,  1.0
        ]
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(canvas_vertices), gl.STATIC_DRAW);
        canvasPositionBuffer.itemSize = 2;
        canvasPositionBuffer.numItems = 4

        //we need to use drawelements so we need to supply the indices of triples of vertices to draw each triangle
        canvasIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, canvasIndexBuffer);
        var triangle_indices = [ 0,1,2, 0,2,3 ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(triangle_indices), gl.STATIC_DRAW);
        canvasIndexBuffer.itemSize = 3;
        canvasIndexBuffer.numItems = 2;

        adjust_texture_size();
        
        vertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
        var vertices = [
             1.0,  1.0,
            -1.0,  1.0,
             1.0, -1.0,
            -1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        vertexPositionBuffer.itemSize = 2;
        vertexPositionBuffer.numItems = 4;

        a_coords_loc =  gl.getAttribLocation(prog_canvas, "a_coords");
        a_texCoords_loc =  gl.getAttribLocation(prog_canvas, "a_texCoords");

        u_texture  = gl.getUniformLocation(prog_canvas, "texture");
        u_texture1 = gl.getUniformLocation(prog_texture, "texture1");

        //location variables are only non null if the data is actually used in a non trivial way in a shader
        offset.x_loc       = gl.getUniformLocation(prog_canvas, "offset_x");
        offset.y_loc       = gl.getUniformLocation(prog_canvas, "offset_y");
        offset.weights_loc = gl.getUniformLocation(prog_canvas, "offset_weights");
        offset.params_loc  = gl.getUniformLocation(prog_canvas, "offset_params");

        init_offsets();

    }

    function adjust_texture_size() {

        var ext  = gl.getExtension('OES_texture_float');
        var ext2 = gl.getExtension('OES_texture_float_linear');

        var tex_size_mult = document.getElementById("tex_size_mult").valueAsNumber;
        tex_size = init_tex_size * Math.pow(2.0,tex_size_mult);  //must be a power of 2
        texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, tex_size, tex_size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, tex_size, tex_size, 0, gl.RGBA, gl.FLOAT, null);
        //With null as the last parameter, the previous method allocates memory for the texture and fills it with zeros.

        //gl.LINEAR blends 4 texture pixels for each on screen pixel
        //gl.NEAREST only takes the nearest after scaling up or down
     
        // MAG is magnification and is in effect if the model face size is larger than texture size
        // MIN is minification and blah blah
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        // The previous line sets the minification filter to gl.LINEAR so we won't neet mipmaps
         
        framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer);  // select the framebuffer, so we can attach the texture to it
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        // The previous line attaches the texture to the framebuffer for use as the color buffer.
      
        // Check form WebGL errors (since I'm not sure all platforms will be able to create the framebuffer) 
        if (gl.getError() != gl.NO_ERROR) {
            throw "Some WebGL error occurred while trying to create framebuffer.";
        }

        //drawScene();

    }

    function init_offsets() {
        var r = 0.0;
        var angle = offset.init_angle;
        var delta_angle = two_pi / offset.num_points * offset.winding_number;
        var delta_r = offset.radius / offset.num_points;
        var delta_weight = 0.0;  //(1.0-.5)/offset.num_points;
        var weight = 1.0;
        for (var i=0; i<offset.num_points; i++) {
            offset.x.push(r*Math.cos(angle));
            offset.y.push(r*Math.sin(angle));
            offset.weights.push(gaussian_kernel_one_stdev[i]);
            offset.sum_weights += weight;
            r += delta_r;
            angle += delta_angle;
            weight -= delta_weight; //linear for now
        }

        offset.params.push(offset.sum_weights);
        var one_pixel = 1.0 / tex_size;
        offset.params.push(one_pixel);

        //can't push an array onto array - it becomes a different type of object - dillhole
        //offset.weights.push(gaussian_kernel);

    }

    // use aspect ratio of actual canvas to prevent displaying a stretched image
    var baseCorners = [];
    var initial_height, initial_width;
    function initialize_corners()
    {
        var cornerIx;
        corners = [];

        for (cornerIx in baseCorners) {
            x = baseCorners[cornerIx][0];
            y = baseCorners[cornerIx][1];
            corners.push(x);
            corners.push(y);

            current_center_x[0] = (corners[0] + corners[2]) / 2.0;
            current_center_y[0] = (corners[3] + corners[5]) / 2.0;
            current_width[0] = corners[0] - current_center_x[0];
            current_height[0] = corners[1] - current_center_y[0];

            current_center_x[1] = (corners[0] + corners[2]) / 2.0;
            current_center_y[1] = (corners[3] + corners[5]) / 2.0;
            current_width[1] = corners[0] - current_center_x[1];
            current_height[1] = corners[1] - current_center_y[1];
 
            initial_height = current_height[0];         
            //initial_height = current_width[0];
            initial_width  = current_width[0];
        }
    }

    var snapshot = [];
    var julia_x = 0.0, julia_y = 0.0;

    function drawScene() {

        //same_mode is to detect when we have just switched from displaying mandel to julia or vica versa

        if (document.getElementById("Mandel_Julia").valueAsNumber > 0) {
            if (doing_julia == 1) {
                same_mode = 0.0;
            }
            else {
                same_mode = 1.0;
            }
            doing_julia = 1;
        } 
        else {
            if (doing_julia == 0) {
                same_mode = 1.0;
            }
            else {
                same_mode = 0.0;
            }
            doing_julia = 0;
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer);
        gl.useProgram(prog_texture);

        gl.disable(gl.DEPTH_TEST); 
        //gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.viewport(0, 0, tex_size, tex_size);

        gl.clearColor(0,0,0,1);

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
        gl.vertexAttribPointer(aVertexPosition, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        var plotPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, plotPositionBuffer);

        var param_data = [];
        snapshot = [];
        var details_at_time_n;
        var mouse_coords = [];

        if (document.getElementById("Julia_Toggle").valueAsNumber > 0 && doing_julia == 1 ) {
            // force cx and cy to be the center of the coordinates on the mandel screen so we 
            // can see the corresponding julia set
            julia_x = current_center_x[0];
            julia_y = current_center_y[0];

            document.getElementById("Param_Radius").valueAsNumber = Math.sqrt(julia_x*julia_x + julia_y*julia_y);
            document.getElementById("Param_Angle").valueAsNumber  = atan(julia_x, julia_y); 
        }

        mouse_coords.push(mousex);
        mouse_coords.push(mousey);
        //only use the mouse coords as the julia param if we are not zooming and mixing
        mouse_coords.push(~zoom_and_mix_instead_of_changing_zparam);
        mouse_coords.push(current_center_x[doing_julia] + current_width[doing_julia] * mousex);
        mouse_coords.push(current_center_y[doing_julia] + current_height[doing_julia] * mousey);
        mouse_coords.push(current_width[doing_julia]);
        mouse_coords.push(current_height[doing_julia]);
        mouse_coords.push(gl.canvas.clientWidth);
        mouse_coords.push(gl.canvas.clientHeight);
        mouse_coords.push(julia_x);
        mouse_coords.push(julia_y);
        mouse_coords.push(current_zoom[doing_julia]);

        // total zoom gets messed up if we stop before the end and then zoom again manually
        if ( running || queue_up_snapshot)  {
            // if we are running a recording then get parameters from the saved data array         
            details_at_time_n = zoom_save[scene_number];

            param_data                    = details_at_time_n['param_details'];
            for (var i in param_data) {
                document.getElementById(params[i]).value = param_data[i];
            }  

            doing_julia                   = details_at_time_n['doing_julia'];
            if (doing_julia === undefined) {
 
                var mandel_julia = document.getElementById("Mandel_Julia").valueAsNumber;
                if ( mandel_julia == 0 ) {
                    doing_julia = 0;
                }
                else {
                    doing_julia = 1;
                } 
            }

            current_center_x[doing_julia] = details_at_time_n['center_x'];
            current_center_y[doing_julia] = details_at_time_n['center_y'];
            current_width[doing_julia]    = details_at_time_n['width'];
            current_height[doing_julia]   = details_at_time_n['height'];

            mouse_coords                  = details_at_time_n['mouse_coords']; 
            if ( mouse_coords === undefined ) {
                mouse_coords = [0,0,0,0,0,0,0,0,0,0,0,0];
            }

            var tmp_zoom                  = details_at_time_n['total_zoom'];
            if ( tmp_zoom === undefined ) {
               current_zoom[doing_julia] = initial_height / current_height[doing_julia];
            }
            else {
               current_zoom[doing_julia] = tmp_zoom;
            }
  
            julia_toggle = document.getElementById("Julia_Toggle").valueAsNumber;

            if ( mouse_coords ) {
                julia_x = mouse_coords[9];
                julia_y = mouse_coords[10];
                if (doing_julia==1 && julia_toggle==1) {
                    //reset mandel so it goes to the right place for this julia set
                    current_center_x[0] = julia_x;
                    current_center_y[0] = julia_y;
                }
            }
            queue_up_snapshot = 0;       
        }
        else {
            // not running a recording, get parameters from the user input form
            for (var i in params) {
                param_data.push(document.getElementById(params[i]).value);
            }
            var zoom_details = {};
            zoom_details['scene_number']  = scene_counter;
            zoom_details['center_x']      = current_center_x[doing_julia];
            zoom_details['center_y']      = current_center_y[doing_julia];
            zoom_details['width']         = current_width[doing_julia];
            zoom_details['height']        = current_height[doing_julia];
            zoom_details['total_zoom']    = current_zoom[doing_julia];
            zoom_details['param_details'] = param_data;
            zoom_details['mouse_coords']  = mouse_coords;
            zoom_details['doing_julia']   = doing_julia;
            zoom_save.push(zoom_details);

            zoom_details['scene_number'] = 0;
            snapshot.push(zoom_details);

            document.getElementById("last_frame").value = scene_counter;
            scene_counter ++;
        }

        var cornerIx;
        corners = [];
        var xwp = current_center_x[doing_julia] + current_width[doing_julia];
        var xwn = current_center_x[doing_julia] - current_width[doing_julia];
        var ywp = current_center_y[doing_julia] + current_height[doing_julia];
        var ywn = current_center_y[doing_julia] - current_height[doing_julia];

        corners.push(xwp);   //(current_center_x + current_width);
        corners.push(ywp);   //(current_center_y + current_height);
        corners.push(xwn);   //(current_center_x - current_width);
        corners.push(ywp);   //(current_center_y + current_height);
        corners.push(xwp);   //(current_center_x + current_width);
        corners.push(ywn);   //(current_center_y - current_height);
        corners.push(xwn);   //(current_center_x - current_width);
        corners.push(ywn);   //(current_center_y - current_height);

        //zooming and translation happens by rescaling the coordinates of the Vertex Shader
        //although since we are not doing any geometric transformations we could have just
        //done it in the Fragment Shader
        document.getElementById("centerX").value = current_center_x[doing_julia];
        document.getElementById("centerY").value = current_center_y[doing_julia];
        document.getElementById("width").value = current_width[doing_julia];
        document.getElementById("height").value = current_height[doing_julia];
        document.getElementById("zoomOutput").value = current_zoom[doing_julia];

        //this is the statement that actually passes the pointer of data from 
        //javascript to shader function in GPU
        gl.uniform1fv(params_location, new Float32Array(param_data));
        gl.uniform1fv(mouse_coords_loc, new Float32Array(mouse_coords));

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(corners), gl.STATIC_DRAW);
        gl.vertexAttribPointer(aPlotPosition, 2, gl.FLOAT, false, 0, 0);

        gl.enableVertexAttribArray(aVertexPosition);
        gl.enableVertexAttribArray(aPlotPosition);

        gl.uniform1i(u_texture1, 1);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        gl.deleteBuffer(plotPositionBuffer);

        //now render the texture to canvas
        gl.bindFramebuffer(gl.FRAMEBUFFER,null); // The null means to use the default framebuffer (which draws onscreen)
        gl.useProgram(prog_canvas);
        gl.uniform1i(u_texture, 0);  // this program uses only texture unit 0

        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT); // | gl.DEPTH_BUFFER_BIT);

        //gl.enable(gl.DEPTH_TEST);  //we do not really need it since we are 2d
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

        gl.bindBuffer(gl.ARRAY_BUFFER, canvasPositionBuffer); 
        gl.vertexAttribPointer(a_coords_loc, 2, gl.FLOAT, false, 0, 0);

        gl.uniform1fv(offset.x_loc, new Float32Array(offset.x));
        gl.uniform1fv(offset.y_loc, new Float32Array(offset.y));
        gl.uniform1fv(offset.weights_loc, new Float32Array(offset.weights));
        gl.uniform1fv(offset.params_loc, new Float32Array(offset.params));
        gl.uniform1fv(params_location2, new Float32Array(param_data));
        gl.uniform1fv(mouse_coords_loc2, new Float32Array(mouse_coords));

        gl.bindBuffer(gl.ARRAY_BUFFER, texturePositionBuffer);
        gl.vertexAttribPointer(a_texCoords_loc, 2, gl.FLOAT, false, 0, 0);

        gl.enableVertexAttribArray(a_coords_loc);
        gl.enableVertexAttribArray(a_texCoords_loc);
        gl.bindTexture(gl.TEXTURE_2D, texture);
         
        //renders the quadrilateral of the canvas buffer by filling in 2 triangles (thus 6 "elements") using indices of the 4 points
        //canvasIndexBuffer is 0,1,2  0,2,3
        //where point 0,1,2,3 are:
        //    -1.0, -1.0,
        //     1.0, -1.0,
        //     1.0,  1.0,
        //    -1.0,  1.0

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, canvasIndexBuffer);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

        gl.disableVertexAttribArray(a_coords_loc);
        gl.disableVertexAttribArray(a_texCoords_loc);

    }

    // example code from mr doob : http://mrdoob.com/lab/javascript/requestanimationframe/
    // requestAnim shim layer by Paul Irish
    window.requestAnimFrame = (function(){
      return  window.requestAnimationFrame       || 
              window.webkitRequestAnimationFrame || 
              window.mozRequestAnimationFrame    || 
              window.oRequestAnimationFrame      || 
              window.msRequestAnimationFrame     || 
              function(/* function */ callback, /* DOMElement */ element){
                window.setTimeout(callback, 1000/60 );
              };
    })();

    // cancelAnimFrame is currently not useful for anything
    window.cancelAnimFrame = (function(){
      return  window.cancelAnimationFrame        ||
              window.webkitCancelAnimationFrame  ||
              window.mozCancelAnimationFrame     ||
              window.oCancelAnimationFrame       ||
              window.msCancelAnimationFrame
              
    })();

    var animation_request;
    var running = false;
    var scene_number_delta = 1;
    var starting_frame = 0;
    var fps,fpsInterval,startTime,now,then,elapsed;

    function run_recording() { 

        //var big_string = JSON.stringify(zoom_save);
        //console.log(big_string);
        //JSON.parse should be able to turn it back

        scene_number = document.getElementById("start_frame").valueAsNumber;
        starting_frame = scene_number;

        running = true;
        julia_mouse = 0; //need to set mouse capture for julia params to off or it does not run
        var cb = document.getElementById("julia_param_checkbox");
        cb.checked=false;

        fps = document.getElementById("fps").valueAsNumber;        
        fpsInterval=1000/fps;
        then=Date.now();
        startTime=then;
        run();
    }

    // recursive function here
    var run = function() {

        if (!running) return;

        animation_request = requestAnimFrame(run);
        now = Date.now();
        elapsed = now - then;

        if (elapsed > fpsInterval) {
            then = now - (elapsed % fpsInterval);
            document.getElementById("scene_number").value = scene_number;
            drawScene();
            scene_number += scene_number_delta; 

            if (scene_number > (scene_counter-1) || scene_number < starting_frame) {
           
                scene_number_delta = -scene_number_delta;
                scene_number += scene_number_delta;
            }
        }
    }

    function stop_running() {
        running = false;
        document.getElementById("start_frame").value = document.getElementById("scene_number").value;
        //cancelAnimFrame(animation_request);
    }

    function sleep(milliseconds) {
        var start = new Date().getTime();
        for (var i = 0; i < 1e7; i++) {
            if ((new Date().getTime() - start) > milliseconds) break;
        }
    }
    
    function apply_zoom(zoom_multiplier) {
        //we also need separate zoom multipliers for mandel vs julia
        document.getElementById("zoom_multiplier").value = zoom_multiplier;
        zoom[doing_julia] *= zoom_multiplier;
        current_width[doing_julia]  /= zoom_multiplier;
        current_height[doing_julia] /= zoom_multiplier; 
        current_zoom[doing_julia] *= zoom_multiplier;
        document.getElementById("zoomOutput").value = current_zoom[doing_julia];

        drawScene();
    }

    var canvas_x_offset = 0;  //210;
    var canvas_y_offset = 0;  //10;
    var mousex, mousey, old_mousex, old_mousey;
    var zoom_and_mix_instead_of_changing_zparam = 0;
    var radius_offset = 0.0, angle_offset = 0.0;
    var last_used_radius = 1.0, last_used_angle = 0.0;
    var doneone_offset = 0;
    var doing_julia = 0;
    var same_mode = 1.0;

    function handleMouseDown(event) {
    
        var button_code = event.button;

        mousex = (event.clientX - canvas_x_offset) / gl.canvas.clientWidth  *  2 - 1;
        mousey = (event.clientY - canvas_y_offset) / gl.canvas.clientHeight * -2 + 1;
 
        if (document.getElementById("Mandel_Julia").valueAsNumber > 0) {
            if (button_code == 2) {

                /* this gets too confusing when in julia set mode
                julia_mouse = 1;
                var cb = document.getElementById("julia_param_checkbox");
                cb.checked=true;

                zoom_and_mix_instead_of_changing_zparam ^= 1;
                if (zoom_and_mix_instead_of_changing_zparam==1) {
                    document.getElementById("current_wheel_param").value = "Mix_Factor";
                    document.getElementById("wheel_param_delta").valueAsNumber = mix_factor_multiplier() / 100.0;
                }
                return false;
                */

                return false;
            }
            if (doing_julia == 0) {
                same_mode = 0.0;
                //so throw out any mouse info
            }
            else {
                same_mode = 1.0;
            }
            doing_julia = 1;
        } 
        else {
            if (doing_julia == 1) {
                same_mode = 0.0;
                //so throw out any mouse info 
            }
            else {
                same_mode = 1.0;
            }
            doing_julia = 0;
            doneone_offset = 0;
        }

        if ( button_code == 1 ) {
           //returning false prevent it from doing annoying default os crap like trying to put a scroll button
           if (julia_mouse==1) {
               if (doing_julia==1) doneone_offset = 1;
               //next time we want this radius and angle to be the center
               last_used_radius = document.getElementById("Param_Radius").valueAsNumber;
               last_used_angle  = document.getElementById("Param_Angle").valueAsNumber;
           }
           else if (doneone_offset==1) {
               radius_offset = last_used_radius - Math.sqrt(mousex*mousex + mousey*mousey);
               angle_offset  = last_used_angle  - atan(mousex, mousey);
               julia_x += mousex;
               julia_y += mousey;               
           }

           //console.log(last_used_radius, radius_offset,julia_mouse,doneone_offset,current_center_x,current_center_y);
           julia_param_from_mouse();

           if (document.getElementById("Mandel_Julia").valueAsNumber == 0 && 
               document.getElementById("Invert_At_Mouse").valueAsNumber ==0 ) {
               document.getElementById("current_wheel_param").value = "Mix_Factor";
               document.getElementById("wheel_param_delta").valueAsNumber = mix_factor_multiplier() / 100.0;
           }
           return false;
        }
        else if ( button_code == 2 ) {
           return false;
        }

        //console.log(same_mode," ",doing_julia);
        //current_center_* should only change with left or right mouse buttons
        current_center_x[doing_julia] += current_width[doing_julia] * mousex * same_mode;
        current_center_y[doing_julia] += current_height[doing_julia] * mousey * same_mode;
        var zoom_multiplier = document.getElementById("zoom_multiplier").value;
        
        apply_zoom(1.0);
    }

    function julia_param_from_mouse() 
    {
        julia_mouse ^= 1;
 
        var cb = document.getElementById("julia_param_checkbox");
        if (julia_mouse==1)
            cb.checked=true;
        else
            cb.checked=false;
    }
  
    //see atanyx in the GL shader section for the same function repeated
    //except the parameters are y,x instead of x,y - what a dumbass
    function atan(x,y) {

        if ( Math.abs(x) < 0.000001 ) {
            if ( y > 0 )  { return pi_over_2; }  else { return three_pi_over_2; }
        }

        var atanyx = Math.atan(y/x);

        //we need to add multiple of pi depending on the quadrant
        if (x>0 && y>=0) {
            return atanyx;
        }
        else if (x<0 && y>=0) {
            return pi + atanyx;
        }
        else if (x<0 && y<=0) {
            return pi + atanyx;
        }
        else {
            return two_pi + atanyx;
        }
    }

    function handleMouseMove(event)
    {

        mousex = (event.clientX - canvas_x_offset) / gl.canvas.clientWidth  *  2 - 1;
        mousey = (event.clientY - canvas_y_offset) / gl.canvas.clientHeight * -2 + 1;  //canvas starts upper left, gl bottom left

        document.getElementById("zoomCenterXInput").value = current_center_x[doing_julia] + current_width[doing_julia]  * mousex;
        document.getElementById("zoomCenterYInput").value = current_center_y[doing_julia] + current_height[doing_julia] * mousey;

        if (julia_mouse==1) {

            if (document.getElementById("Mandel_Julia").valueAsNumber > 0 && zoom_and_mix_instead_of_changing_zparam == 0) {
                //we need to set Param Radius and Param Angle so that the julia coords are recorded
                var zparam_mult = document.getElementById("Julia_Param_Mult").valueAsNumber;
                document.getElementById("Param_Radius").valueAsNumber = zparam_mult*(Math.sqrt(mousex*mousex + mousey*mousey) + recenter_julia_params*radius_offset);
                document.getElementById("Param_Angle").valueAsNumber  =             (atan(mousex, mousey)                     + recenter_julia_params*angle_offset );
                julia_x = mousex;
                julia_y = mousey;
                drawScene();
            }

            else if (document.getElementById("Invert_At_Mouse").valueAsNumber > 0) {
                drawScene();
            }
 
            else { 

                var current_mix_factor = document.getElementById("Mix_Factor").valueAsNumber; 
                var mousex_distance = mousex - old_mousex;

                //we want it to change less as we are zooming in
                mousex_distance *= mix_factor_multiplier();
                 
                if ( (mousex > .4 && mousex_distance > 0.0 ) || (mousex < -.4 && mousex_distance < 0.0 ) ) {
                    current_mix_factor += mousex_distance;
                }
                
                document.getElementById("Mix_Factor").valueAsNumber = current_mix_factor;   

                if ( mousey > .5 && mousey > old_mousey ) {
                    zoom_multiplier = 1.05;
                }
                else if ( mousey < -.5 && mousey < old_mousey ) {
                    zoom_multiplier = .95;
                }
                else {
                    zoom_multiplier = 1.0;
                }
                   
                document.getElementById("wheel_param_delta").valueAsNumber = mix_factor_multiplier() / 100.0;
                //apply_zoom() draws scene at the end
                apply_zoom(zoom_multiplier);
            }
     
        }
 
        old_mousex = mousex;
        old_mousey = mousey;
    }

    function mix_factor_multiplier() {
        var wheel_param_delta  = document.getElementById("wheel_param_delta").valueAsNumber;
        var expand_contract    = document.getElementById("Julia_Param_Mult").valueAsNumber;         
        return expand_contract * 2.0 / current_zoom[doing_julia];
    }

    function handleMouseWheel(event) {

        var wheel = event.wheelDelta;
	wheel /= Math.abs(wheel);  //normalize it to 1 since mouse wheel and gestures give 2 different values

        document.getElementById("zoom_multiplier").value = 1.0;
        //increment or decrement signal can come from mouse wheel or cursor keys

        if (julia_mouse==1) {

            if (document.getElementById("Mandel_Julia").valueAsNumber > 0 && zoom_and_mix_instead_of_changing_zparam == 0) {
                //we need to set Param Radius and Param Angle so that the julia coords are recorded
                var zparam_mult = document.getElementById("Julia_Param_Mult").valueAsNumber;
                document.getElementById("Param_Radius").valueAsNumber = zparam_mult*(Math.sqrt(mousex*mousex + mousey*mousey) + recenter_julia_params*radius_offset);
                document.getElementById("Param_Angle").valueAsNumber  =             (atan(mousex, mousey)                     + recenter_julia_params*angle_offset );
                julia_x = mousex;
                julia_y = mousey;
            }
        }

        update_params_and_redraw(wheel);
    }

    function make_delta_smaller() {
        var wheel_param_delta = document.getElementById("wheel_param_delta").valueAsNumber;
        wheel_param_delta /= 10.0;
        document.getElementById("wheel_param_delta").value = wheel_param_delta;
    }

    function update_params_and_redraw(delta) {

        var wheel_param_name = document.getElementById("current_wheel_param").value;
        var wheel_param = document.getElementById(wheel_param_name).valueAsNumber;
        document.getElementById("wheel_param_value").value = wheel_param;

        var wheel_param_delta = document.getElementById("wheel_param_delta").valueAsNumber;
        
        var wheel_delta = delta * wheel_param_delta;

        wheel_param += wheel_delta;

        document.getElementById("mouse_wheel").value = wheel_delta;
        document.getElementById(wheel_param_name).value = wheel_param;

        drawScene();
    }

    function apply_zoom_from_keypress(temp_zoom_multiplier) {

        var zoom_multiplier = document.getElementById("zoom_multiplier").value;
     
        //we want to maintain the zoommultiplier from the input form if it is already going in
        //the correct direction
        if (temp_zoom_multiplier > 1.0 ) {
            if ( zoom_multiplier <= 1.0 ) zoom_multiplier = temp_zoom_multiplier;
        }
        else if (temp_zoom_multiplier < 1.0) {
            if ( zoom_multiplier >= 1.0 ) zoom_multiplier = temp_zoom_multiplier;
        }
        else {
            zoom_multiplier = temp_zoom_multiplier;   
        }

        apply_zoom(zoom_multiplier);
          
    }

    function handleKeyPress(event) {

        var ce = document.activeElement;
        if (ce.id != '' && ce.id == "download_file") return;

        var delta = 0.0;
        if (event.keyCode == 38 )  // arrow up
        {
            delta = 1.0;
            update_params_and_redraw(delta);
            return false;
        }
        else if (event.keyCode == 40 ) //arrow down
        {
            delta = -1.0
            update_params_and_redraw(delta);
            return false;
        }
        else if (event.keyCode == 90 ) //z
        {
            apply_zoom_from_keypress(1.1);
        }
        else if (event.keyCode == 88) //x
        {
            apply_zoom_from_keypress(1.0/1.1);
        }
        else if (event.keyCode == 77) //m
        {
            julia_param_from_mouse();
        }
        else if (event.keyCode == 74) //j
        {
            //julia_map_using_current_
            var toggle_value = doing_julia;
            toggle_value ^= 1;
            doing_julia = toggle_value;
            document.getElementById("Mandel_Julia").value = toggle_value;
            document.getElementById("Julia_Toggle").value = 1;
            drawScene(); 
        }
        else if (event.keyCode == 72) //h
        {
            toggle_hidden_attribute();
            //rescale canvas and gl drawing area to maximum
        }

        //returning false from these events prevents the default processing
        //such as translating up arrow to scroll a region

    }

    function set_wheel(x1) {
        document.getElementById("current_wheel_param").value = params[x1];
        document.getElementById("wheel_param_delta").value = param_default_deltas[x1];
    }


/* Creates a program for use in the WebGL context gl, and returns the
 * identifier for that program.  If an error occurs while compiling or
 * linking the program, an exception of type String is thrown.  The error
 * string contains the compilation or linking error.  If no error occurs,
 * the program identifier is the return value of the function.
 *    The second and third parameters are the id attributes for <script>
 * elementst that contain the source code for the vertex and fragment
 * shaders.
 */
  function createProgram(gl, vertexShaderID, fragmentShaderID) {
    function getTextContent( elementID ) {
            // This nested function retrieves the text content of an
            // element on the web page.  It is used here to get the shader
            // source code from the script elements that contain it.
        var element = document.getElementById(elementID);
        var node = element.firstChild;
        var str = "";
        while (node) {
            if (node.nodeType == 3) // this is a text node
                str += node.textContent;
            node = node.nextSibling;
        }
        return str;
    }
    try {
        var vertexShaderSource = getTextContent( vertexShaderID );
        var fragmentShaderSource = getTextContent( fragmentShaderID );
    }
    catch (e) {
        throw "Error: Could not get shader source code from script elements.";
    }
    var vsh = gl.createShader( gl.VERTEX_SHADER );
    gl.shaderSource(vsh,vertexShaderSource);
    gl.compileShader(vsh);
    if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
        throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
     }
    var fsh = gl.createShader( gl.FRAGMENT_SHADER );
    gl.shaderSource(fsh, fragmentShaderSource);
    gl.compileShader(fsh);
    if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
       throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
    }
    var prog = gl.createProgram();
    gl.attachShader(prog,vsh);
    gl.attachShader(prog, fsh);
    gl.linkProgram(prog);
    if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
       throw "Link error in program:  " + gl.getProgramInfoLog(prog);
    }
    return prog;
  }

    function initGL(canvas) {
        try {
            gl = canvas.getContext("webgl",{antialias:true})  || canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
            var size = gl.getParameter(gl.SAMPLES);
            console.log("antialiasing samples ",size);
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    var init_canvas_width_fract = 1.0;
    var init_canvas_height_fract = .997;

    var canvas_width_fract = init_canvas_width_fract;
    var canvas_height_fract = init_canvas_height_fract;

    function resizeCanvas() {	
        // have to resize other stuff like the gl viewport and not sure what else
   
        var canvas_mult = document.getElementById("canvas_mult").valueAsNumber;	
        canvas.width = window.innerWidth * canvas_width_fract * canvas_mult;			
        canvas.height = window.innerHeight * canvas_height_fract * canvas_mult;
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;

        //divs can be dynamically resized by just doing this
        var div1 = document.getElementById("user_params");   

        // need to change this in multiple places
        if (div1.style.display != "none") {
            var div_height = Math.max(window.innerHeight - 280 - 60,10);
            var st ="position:absolute; top:320px; left:10px; z-index:0; font-size:12px; overflow:scroll; background-color:lightblue; width:212px; height:" + div_height + "px";
	    div1.setAttribute('style', st);
        }
    }

    function toggle_hidden_attribute() {
        var x  = document.getElementById("user_params");
        var x2 = document.getElementById("save_file");
        var x3 = document.getElementById("d2"); 
        var canvas = document.getElementById("canvas01_div");

        if (x.style.display === "none") {
            x.style.display  = "block";
            x2.style.display = "block";
            x3.style.display = "block";
        } else {
            x.style.display =  "none";
            x2.style.display = "none";
            x3.style.display = "none";
        }         

    }

    var canvas = document.getElementById("canvas01");
    var base_width = 2.0;

    function webGLStart() {

        console.log("we made it to webGLStart");

        if (window.File && window.FileReader && window.FileList && window.Blob) {
            // Great success! All the File APIs are supported.
            // only add the event listener if the file api is supported
            document.getElementById('files').addEventListener('change', handleFileSelect, false);
        } else {
            alert('The File APIs are not fully supported in this browser.');
        }

        zoom[doing_julia] = 1.0;
 
        canvas.width  = window.innerWidth  * canvas_width_fract;			
        canvas.height = window.innerHeight * canvas_height_fract;

        var aspect_ratio = canvas.width / canvas.height;
  
        var corner_x = base_width*aspect_ratio;
        baseCorners.push( [corner_x, base_width] );
        baseCorners.push( [-corner_x, base_width] );
        baseCorners.push( [corner_x, -base_width] );
        baseCorners.push( [-corner_x, -base_width] );

        initGL(canvas);
      
        //color_map_urls is an array of images converted to base 64
        //https://www.askapache.com/online-tools/base64-image-converter/
        load_new_texture();

        prog_canvas  = createProgram(gl,"vshader","fshader");

        prog_texture = createProgram(gl,"shader-vs","shader-fs");
        gl.useProgram(prog_texture);
        init_Buffers();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);

	  window.addEventListener('resize', resizeCanvas, false);
      
        //do not really need initialize_corners and the rest if we just
        //stick to the Fragment Shader
        initialize_corners();

        canvas.onmousedown = handleMouseDown;
        canvas.onmousemove = handleMouseMove;
        canvas.onmousewheel = handleMouseWheel;
        document.onkeydown = handleKeyPress; 

        var snapshot_mode = document.getElementById("snapshot_checkbox");
        snapshot_mode.checked = true;

        var div1 = document.getElementById("user_params");
        var div_height = Math.max(window.innerHeight - 280 - 60,10);
        var st ="position:absolute; top:320px; left:10px; z-index:0; font-size:12px; overflow:scroll; background-color:lightblue; width:212px; height:" + div_height + "px";
	  div1.setAttribute('style', st);

        var newform = document.createElement('form');
        div1.appendChild(newform);

        for (var p in params) {

            var i = document.createElement('input');
            i.type='number';
            i.id=params[p];
            i.value=initial_values[p];
            i.setAttribute('style','font-size:10px; width:60px');
            i.onblur = function(){drawScene();};
            i.onchange = function(){drawScene();};

            var b = document.createElement('input');
            b.type='button';
            b.setAttribute('style','position:relative; top: 4px; font-size:9px');

            //how the f..k would anyone figure this out???
            //http://stackoverflow.com/questions/3495679/passing-parameters-in-javascript-onclick-event
            b.onclick= ( function() { var current_p = p; 
                                      return function() { set_wheel(current_p + ''); }
                                    } ) ();

            newform.appendChild(i);
            newform.appendChild(document.createTextNode('\u00A0\u00A0'));
            newform.appendChild(b);
            newform.appendChild(document.createTextNode('\u00A0'));
            newform.appendChild(document.createTextNode(params[p]));
            newform.appendChild(document.createElement('br'));
        }


/* this is a better way than setInterval to repeat a function over and over
https://sarfraznawaz.wordpress.com/2012/01/26/javascript-self-invoking-functions/
! function foo(){
 // your other code here
 
setTimeout(foo, 10000);
 
}();
*/

        drawScene();
    }

function loadTexture(gl, url) {

  gl.activeTexture(gl.TEXTURE1);

  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Because images have to be download over the internet
  // they might take a moment until they are ready.
  // Until then put a single pixel in the texture so we can
  // use it immediately. When the image has finished downloading
  // we'll update the texture with the contents of the image.
  const level = 0;
  const internalFormat = gl.RGBA;
  const width = 1;
  const height = 1;
  const border = 0;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  const pixel = new Uint8Array([0, 0, 255, 255]);  // opaque blue
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border, srcFormat, srcType,
                pixel);

  const image = new Image();
  image.onload = function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                  srcFormat, srcType, image);

    // WebGL1 has different requirements for power of 2 images
    // vs non power of 2 images so check if the image is a
    // power of 2 in both dimensions.
    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
       // Yes, it's a power of 2. Generate mips.
       gl.generateMipmap(gl.TEXTURE_2D);
       //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    } else {
       // No, it's not a power of 2. Turn off mips and set
       // wrapping to clamp to edge
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }

     drawScene();

  };
  image.src = url;

  gl.activeTexture(gl.TEXTURE0);

  return texture;
}

function isPowerOf2(value) {
  return (value & (value - 1)) == 0;
}

function load_new_texture() {
  var text_num_to_load =  document.getElementById("tex_map_num").valueAsNumber;
  loadTexture(gl, color_map_urls[text_num_to_load]);
}

</script>

</html>
